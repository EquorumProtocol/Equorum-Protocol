{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/EquorumFaucetDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"./interfaces/IEquorumCore.sol\";\r\n\r\n/**\r\n * @title EquorumFaucetDistributor\r\n * @author Equorum Protocol\r\n * @notice Manages free EQM token distribution via faucet system\r\n * @dev Simplified version of original EquorumFaucet without external dependencies\r\n * \r\n * FEATURES:\r\n * - Controlled distribution of 2.256M tokens\r\n * - 24-hour cooldown between claims\r\n * - Global daily limit protection\r\n * - Whitelist system for trusted users\r\n * - Anti-bot protections (contract blocking, minimum balance)\r\n * - Pausable for emergency control\r\n * - Compatible with IEquorumCore interface\r\n * \r\n * SECURITY:\r\n * - Whitelist-only mode available\r\n * - Contract address blocking\r\n * - Minimum ETH balance requirement\r\n * - Account age verification\r\n * - Blacklist system\r\n * - ReentrancyGuard on all state-changing functions\r\n * \r\n * ARBITRUM L2 OPTIMIZATIONS:\r\n * - Packed storage layout\r\n * - Minimal SLOAD operations\r\n * - Gas-efficient daily resets\r\n * - Event-driven state tracking\r\n * - Optimized for low L2 gas costs\r\n */\r\ncontract EquorumFaucetDistributor is IEquorumCore, Ownable, Pausable, ReentrancyGuard {\r\n    \r\n    // ========== CUSTOM ERRORS ==========\r\n    error InvalidAddress();\r\n    error AddressBlacklisted();\r\n    error NoContractsAllowed();\r\n    error NotWhitelisted();\r\n    error InsufficientETHBalance();\r\n    error AccountTooNew();\r\n    error CooldownActive();\r\n    error UserLimitExceeded();\r\n    error DailyLimitExceeded();\r\n    error FaucetAllocationExceeded();\r\n    error InsufficientFaucetBalance();\r\n    error TransferFailed();\r\n    error InsufficientBalance();\r\n    \r\n    // ========== CONSTANTS ==========\r\n    \r\n    /// @notice Total faucet allocation (2.256M EQM)\r\n    uint256 public constant FAUCET_ALLOCATION = 2_256_000 * 1e18;\r\n    \r\n    /// @notice Base claim amount per request (0.001 EQM - micro amounts for sustainability)\r\n    uint256 public constant BASE_CLAIM_AMOUNT = 0.001 * 1e18;\r\n    \r\n    /// @notice Cooldown period between claims (24 hours)\r\n    uint256 public constant CLAIM_COOLDOWN = 1 days;\r\n    \r\n    /// @notice Global daily distribution limit (10 EQM/day - sustainable)\r\n    uint256 public constant DAILY_LIMIT = 10 * 1e18;\r\n    \r\n    /// @notice Maximum tokens per user lifetime (0.05 EQM - prevents abuse)\r\n    uint256 public constant MAX_PER_USER = 0.05 * 1e18;\r\n    \r\n    /// @notice Minimum ETH balance required to claim (0.001 ETH)\r\n    uint256 public constant MIN_ETH_BALANCE = 0.001 ether;\r\n    \r\n    /// @notice Minimum account age in blocks (~1 hour on Arbitrum)\r\n    uint256 public constant MIN_ACCOUNT_AGE = 14400; // ~1 hour at 0.25s/block\r\n    \r\n    // ========== STATE VARIABLES ==========\r\n    \r\n    /// @notice EQM token contract\r\n    IERC20 public immutable equorumToken;\r\n    \r\n    /// @notice Block number when contract was deployed\r\n    uint256 public immutable deployBlock;\r\n    \r\n    /// @notice Whether whitelist mode is active\r\n    bool public whitelistMode;\r\n    \r\n    /// @notice Last claim timestamp for each user\r\n    mapping(address => uint256) public lastClaim;\r\n    \r\n    /// @notice Total claimed by each user\r\n    mapping(address => uint256) public totalClaimed;\r\n    \r\n    /// @notice Blacklisted addresses\r\n    mapping(address => bool) public blacklisted;\r\n    \r\n    /// @notice Whitelisted addresses (only used if whitelistMode is true)\r\n    mapping(address => bool) public whitelisted;\r\n    \r\n    /// @notice First interaction block for each address\r\n    mapping(address => uint256) public firstBlock;\r\n    \r\n    /// @notice Total distributed today\r\n    uint256 public dailyDistributed;\r\n    \r\n    /// @notice Timestamp of last daily reset\r\n    uint256 public lastDailyReset;\r\n    \r\n    /// @notice Total distributed (lifetime)\r\n    uint256 public totalDistributed;\r\n    \r\n    // ========== EVENTS ==========\r\n    \r\n    /// @notice Emitted when tokens are claimed\r\n    event TokensClaimed(address indexed user, uint256 amount, uint256 timestamp);\r\n    \r\n    /// @notice Emitted when user blacklist status changes\r\n    event UserBlacklisted(address indexed user, bool status);\r\n    \r\n    /// @notice Emitted when user whitelist status changes\r\n    event UserWhitelisted(address indexed user, bool status);\r\n    \r\n    /// @notice Emitted when whitelist mode changes\r\n    event WhitelistModeChanged(bool enabled);\r\n    \r\n    /// @notice Emitted when daily limit resets\r\n    event DailyLimitReset(uint256 timestamp);\r\n    \r\n    /// @notice Emitted when emergency withdrawal occurs\r\n    event EmergencyWithdrawal(address indexed to, uint256 amount);\r\n    \r\n    // ========== CONSTRUCTOR ==========\r\n    \r\n    /**\r\n     * @notice Initializes the faucet distributor\r\n     * @dev Contract starts PAUSED - owner must unpause to activate\r\n     * @param _equorumToken Address of EQM token contract\r\n     */\r\n    constructor(address _equorumToken) {\r\n        if (_equorumToken == address(0)) revert InvalidAddress();\r\n        \r\n        equorumToken = IERC20(_equorumToken);\r\n        deployBlock = block.number;\r\n        lastDailyReset = block.timestamp;\r\n        \r\n        // Start paused - owner activates when ready\r\n        _pause();\r\n    }\r\n    \r\n    // ========== CORE FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Claims tokens from faucet\r\n     * @dev Performs multiple security checks before distribution\r\n     * \r\n     * SECURITY CHECKS:\r\n     * - Not blacklisted\r\n     * - Whitelist check (if enabled)\r\n     * - Not a contract address\r\n     * - Has minimum ETH balance\r\n     * - Account age requirement\r\n     * - Cooldown period\r\n     * - User lifetime limit\r\n     * - Daily global limit\r\n     * \r\n     * ARBITRUM OPTIMIZATION:\r\n     * - Single SSTORE for daily reset\r\n     * - Packed state updates\r\n     * - Minimal external calls\r\n     */\r\n    function claim() external nonReentrant whenNotPaused {\r\n        address user = msg.sender;\r\n        \r\n        // Security checks\r\n        if (blacklisted[user]) revert AddressBlacklisted();\r\n        if (user.code.length != 0) revert NoContractsAllowed();\r\n        \r\n        // Whitelist check (if enabled)\r\n        if (whitelistMode && !whitelisted[user]) revert NotWhitelisted();\r\n        \r\n        // Anti-sybil checks (skip for whitelisted users)\r\n        if (!whitelisted[user]) {\r\n            if (user.balance < MIN_ETH_BALANCE) revert InsufficientETHBalance();\r\n            \r\n            // Track first interaction\r\n            if (firstBlock[user] == 0) {\r\n                firstBlock[user] = block.number;\r\n            }\r\n            if (block.number < firstBlock[user] + MIN_ACCOUNT_AGE) revert AccountTooNew();\r\n        }\r\n        \r\n        // Cooldown check\r\n        if (block.timestamp < lastClaim[user] + CLAIM_COOLDOWN) revert CooldownActive();\r\n        \r\n        // User limit check\r\n        if (totalClaimed[user] + BASE_CLAIM_AMOUNT > MAX_PER_USER) revert UserLimitExceeded();\r\n        \r\n        // Daily reset if needed (gas-optimized)\r\n        if (block.timestamp >= lastDailyReset + 1 days) {\r\n            dailyDistributed = 0;\r\n            lastDailyReset = block.timestamp;\r\n            emit DailyLimitReset(block.timestamp);\r\n        }\r\n        \r\n        // Daily limit check\r\n        if (dailyDistributed + BASE_CLAIM_AMOUNT > DAILY_LIMIT) revert DailyLimitExceeded();\r\n        \r\n        // FAUCET_ALLOCATION enforcement (prevents distributing beyond allocation)\r\n        if (totalDistributed + BASE_CLAIM_AMOUNT > FAUCET_ALLOCATION) revert FaucetAllocationExceeded();\r\n        \r\n        // Contract balance check\r\n        if (equorumToken.balanceOf(address(this)) < BASE_CLAIM_AMOUNT) revert InsufficientFaucetBalance();\r\n        \r\n        // Update state (packed for gas efficiency)\r\n        lastClaim[user] = block.timestamp;\r\n        totalClaimed[user] += BASE_CLAIM_AMOUNT;\r\n        dailyDistributed += BASE_CLAIM_AMOUNT;\r\n        totalDistributed += BASE_CLAIM_AMOUNT;\r\n        \r\n        // Transfer tokens\r\n        if (!equorumToken.transfer(user, BASE_CLAIM_AMOUNT)) revert TransferFailed();\r\n        \r\n        emit TokensClaimed(user, BASE_CLAIM_AMOUNT, block.timestamp);\r\n    }\r\n    \r\n    // ========== ADMIN FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Sets blacklist status for an address\r\n     * @param user Address to update\r\n     * @param status True to blacklist, false to remove\r\n     */\r\n    function setBlacklist(address user, bool status) external onlyOwner {\r\n        if (user == address(0)) revert InvalidAddress();\r\n        blacklisted[user] = status;\r\n        emit UserBlacklisted(user, status);\r\n    }\r\n    \r\n    /**\r\n     * @notice Sets whitelist status for an address\r\n     * @param user Address to update\r\n     * @param status True to whitelist, false to remove\r\n     */\r\n    function setWhitelist(address user, bool status) external onlyOwner {\r\n        if (user == address(0)) revert InvalidAddress();\r\n        whitelisted[user] = status;\r\n        emit UserWhitelisted(user, status);\r\n    }\r\n    \r\n    /**\r\n     * @notice Batch whitelist multiple addresses\r\n     * @dev Gas-optimized for multiple additions\r\n     * @param users Array of addresses to whitelist\r\n     */\r\n    function batchWhitelist(address[] calldata users) external onlyOwner {\r\n        uint256 length = users.length;\r\n        for (uint256 i = 0; i < length;) {\r\n            whitelisted[users[i]] = true;\r\n            emit UserWhitelisted(users[i], true);\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Enables or disables whitelist mode\r\n     * @param enabled True to enable whitelist-only mode\r\n     */\r\n    function setWhitelistMode(bool enabled) external onlyOwner {\r\n        whitelistMode = enabled;\r\n        emit WhitelistModeChanged(enabled);\r\n    }\r\n    \r\n    /**\r\n     * @notice Activates the faucet (unpauses)\r\n     * @dev Owner calls when ready to start distribution\r\n     */\r\n    function activate() external onlyOwner {\r\n        _unpause();\r\n    }\r\n    \r\n    /**\r\n     * @notice Deactivates the faucet (pauses)\r\n     */\r\n    function deactivate() external onlyOwner {\r\n        _pause();\r\n    }\r\n    \r\n    /**\r\n     * @notice Emergency withdrawal of tokens\r\n     * @param to Destination address\r\n     * @param amount Amount to withdraw\r\n     */\r\n    function emergencyWithdraw(address to, uint256 amount) external onlyOwner {\r\n        if (to == address(0)) revert InvalidAddress();\r\n        uint256 balance = equorumToken.balanceOf(address(this));\r\n        if (amount > balance) revert InsufficientBalance();\r\n        \r\n        if (!equorumToken.transfer(to, amount)) revert TransferFailed();\r\n        emit EmergencyWithdrawal(to, amount);\r\n    }\r\n    \r\n    // ========== VIEW FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Checks if user can claim tokens\r\n     * @param user Address to check\r\n     * @return canClaim True if user can claim\r\n     * @return timeUntilNext Seconds until next claim (0 if can claim now)\r\n     * @dev Mirrors claim() logic exactly for consistency\r\n     */\r\n    function canUserClaim(address user) external view returns (bool canClaim, uint256 timeUntilNext) {\r\n        // Basic checks\r\n        if (paused()) return (false, 0);\r\n        if (blacklisted[user]) return (false, 0);\r\n        if (user.code.length != 0) return (false, 0); // No contracts\r\n        \r\n        // Whitelist check\r\n        if (whitelistMode && !whitelisted[user]) return (false, 0);\r\n        \r\n        // Anti-sybil checks (skip for whitelisted users - mirrors claim())\r\n        if (!whitelisted[user]) {\r\n            if (user.balance < MIN_ETH_BALANCE) return (false, 0);\r\n            if (firstBlock[user] > 0 && block.number < firstBlock[user] + MIN_ACCOUNT_AGE) return (false, 0);\r\n        }\r\n        \r\n        // User limit check\r\n        if (totalClaimed[user] + BASE_CLAIM_AMOUNT > MAX_PER_USER) return (false, 0);\r\n        \r\n        // Daily limit check (approximate - doesn't account for pending reset)\r\n        uint256 currentDailyDistributed = dailyDistributed;\r\n        if (block.timestamp >= lastDailyReset + 1 days) {\r\n            currentDailyDistributed = 0; // Would reset on claim\r\n        }\r\n        if (currentDailyDistributed + BASE_CLAIM_AMOUNT > DAILY_LIMIT) return (false, 0);\r\n        \r\n        // FAUCET_ALLOCATION check\r\n        if (totalDistributed + BASE_CLAIM_AMOUNT > FAUCET_ALLOCATION) return (false, 0);\r\n        \r\n        // Contract balance check\r\n        if (equorumToken.balanceOf(address(this)) < BASE_CLAIM_AMOUNT) return (false, 0);\r\n        \r\n        // Cooldown check\r\n        uint256 nextClaimTime = lastClaim[user] + CLAIM_COOLDOWN;\r\n        if (block.timestamp < nextClaimTime) {\r\n            return (false, nextClaimTime - block.timestamp);\r\n        }\r\n        \r\n        return (true, 0);\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns user statistics\r\n     * @param user Address to query\r\n     */\r\n    function getUserStats(address user) external view returns (\r\n        uint256 lastClaimTime,\r\n        uint256 totalClaimedAmount,\r\n        uint256 remainingAllowance,\r\n        bool isBlacklisted,\r\n        bool isWhitelisted\r\n    ) {\r\n        return (\r\n            lastClaim[user],\r\n            totalClaimed[user],\r\n            MAX_PER_USER - totalClaimed[user],\r\n            blacklisted[user],\r\n            whitelisted[user]\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns contract balance\r\n     */\r\n    function getContractBalance() external view returns (uint256) {\r\n        return equorumToken.balanceOf(address(this));\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns faucet statistics\r\n     */\r\n    function getFaucetStats() external view returns (\r\n        uint256 totalDist,\r\n        uint256 dailyDist,\r\n        uint256 remaining,\r\n        uint256 lastReset,\r\n        bool isPaused,\r\n        bool isWhitelistMode\r\n    ) {\r\n        return (\r\n            totalDistributed,\r\n            dailyDistributed,\r\n            equorumToken.balanceOf(address(this)),\r\n            lastDailyReset,\r\n            paused(),\r\n            whitelistMode\r\n        );\r\n    }\r\n    \r\n    // ========== IEQUORUMCORE IMPLEMENTATION ==========\r\n    \r\n    /**\r\n     * @notice Processes system action\r\n     * @dev Action types: 1=Regular (daily reset), 2=Critical (pause if low), 3=Emergency (pause)\r\n     * @param actionType Type of action\r\n     * @param data Additional data (unused)\r\n     */\r\n    function processSystemAction(uint8 actionType, bytes calldata data) external override onlyOwner {\r\n        if (actionType == 1) {\r\n            // Regular: Force daily reset if needed\r\n            if (block.timestamp >= lastDailyReset + 1 days) {\r\n                dailyDistributed = 0;\r\n                lastDailyReset = block.timestamp;\r\n                emit DailyLimitReset(block.timestamp);\r\n            }\r\n        } else if (actionType == 2) {\r\n            // Critical: Pause if balance low\r\n            uint256 balance = equorumToken.balanceOf(address(this));\r\n            if (balance < DAILY_LIMIT / 10) {\r\n                _pause();\r\n            }\r\n        } else if (actionType == 3) {\r\n            // Emergency: Immediate pause\r\n            _pause();\r\n        }\r\n        \r\n        emit SystemAction(address(this), \"Faucet action\", actionType, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Emergency stop\r\n     * @param reason Reason for stop\r\n     */\r\n    function emergencyStop(string calldata reason) external override onlyOwner {\r\n        _pause();\r\n        emit EmergencyAction(address(this), reason, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Updates parameters (not supported - values are constants)\r\n     * @dev Kept for IEquorumCore compatibility\r\n     */\r\n    function updateParameters(string[] calldata, uint256[] calldata) external override onlyOwner {\r\n        // Faucet uses constants - no parameter updates\r\n        emit SystemAction(address(this), \"Parameter update not supported\", 0, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Validates contract state\r\n     * @return checksum Hash of current state\r\n     */\r\n    function validateState() external view override returns (bytes32) {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                address(equorumToken),\r\n                totalDistributed,\r\n                dailyDistributed,\r\n                lastDailyReset,\r\n                paused(),\r\n                whitelistMode\r\n            )\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @notice Verifies integrations\r\n     * @param contracts Array with [equorumToken]\r\n     * @return valid True if integration valid\r\n     */\r\n    function verifyIntegrations(address[] calldata contracts) external view override returns (bool) {\r\n        if (contracts.length != 1) return false;\r\n        return contracts[0] == address(equorumToken);\r\n    }\r\n}\r\n"
    },
    "contracts/EquorumGenesisVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\n/**\r\n * @title EquorumGenesisVesting\r\n * @notice IMMUTABLE vesting contract for Genesis allocation\r\n * @dev Optimized for Arbitrum L2 with efficient storage and gas patterns\r\n * \r\n * SECURITY & IMMUTABILITY:\r\n * - 100% IMMUTABLE - Cannot be changed after deployment\r\n * - NO admin functions - No one can stop or modify vesting\r\n * - NO ownership transfer - Genesis address is fixed forever\r\n * - NO emergency withdrawal - True vesting guarantee\r\n * - Automatic vesting schedule - Guaranteed 72-month release\r\n * - Protected against fraud - All parameters are immutable constants\r\n * \r\n * GENESIS RESTRICTIONS (ANTI-MANIPULATION):\r\n * - Genesis CANNOT vote in governance\r\n * - Genesis CANNOT stake tokens\r\n * - Genesis ONLY receives vested tokens as payment for development\r\n * \r\n * FEATURES:\r\n * - 3M tokens vested over 72 months (6 years)\r\n * - Monthly release: 41,666.66 EQM (automatic)\r\n * - Automatic catch-up if months are missed\r\n * - Works seamlessly after vesting completion (72+ months)\r\n * - isFunded() view to verify contract has tokens before release\r\n * \r\n * RECOMMENDED SETUP:\r\n * - Use Gnosis Safe multisig (2/3 or 3/5) as genesisAddress\r\n * - Store keys in hardware wallets (Ledger/Trezor)\r\n * - Distribute signers across different locations\r\n * - This eliminates single point of failure\r\n * \r\n * ARBITRUM L2 OPTIMIZATIONS:\r\n * - Immutable variables for gas savings\r\n * - Compact storage layout\r\n * - Efficient timestamp calculations\r\n */\r\ncontract EquorumGenesisVesting is ReentrancyGuard {\r\n    \r\n    // ========== CUSTOM ERRORS ==========\r\n    /// @notice Thrown when caller is not the genesis address\r\n    error OnlyGenesis();\r\n    /// @notice Thrown when there are no tokens available to release\r\n    error NoTokensToRelease();\r\n    /// @notice Thrown when token transfer fails\r\n    error TransferFailed();\r\n    /// @notice Thrown when address is zero\r\n    error InvalidAddress();\r\n    \r\n    // ========== CONSTANTS ==========\r\n    /// @notice Total Genesis allocation (3 million tokens)\r\n    uint256 public constant GENESIS_ALLOCATION = 3_000_000 * 1e18;\r\n    \r\n    /// @notice Vesting duration in months\r\n    uint256 public constant VESTING_DURATION = 72;\r\n    \r\n    /// @notice Monthly release amount (3M / 72 months)\r\n    uint256 public constant MONTHLY_RELEASE = 41_666_666666666666666666; // 41,666.66 tokens\r\n    \r\n    /// @notice Seconds in a month (30 days)\r\n    uint256 public constant SECONDS_PER_MONTH = 30 days;\r\n    \r\n    // ========== STATE VARIABLES ==========\r\n    /// @notice Equorum token contract (immutable for gas savings)\r\n    IERC20 public immutable equorumToken;\r\n    \r\n    /// @notice Genesis beneficiary address (immutable)\r\n    address public immutable genesisAddress;\r\n    \r\n    /// @notice Vesting start timestamp (immutable)\r\n    uint256 public immutable releaseStartTime;\r\n    \r\n    /// @notice Total tokens released so far\r\n    uint256 public releasedTokens;\r\n    \r\n    /// @notice Last release timestamp (for tracking)\r\n    uint256 public lastReleaseTimestamp;\r\n    \r\n    // ========== EVENTS ==========\r\n    event TokensReleased(\r\n        address indexed beneficiary,\r\n        uint256 amount,\r\n        uint256 monthsPassed,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    // ========== MODIFIERS ==========\r\n    modifier onlyGenesis() {\r\n        if (msg.sender != genesisAddress) revert OnlyGenesis();\r\n        _;\r\n    }\r\n    \r\n    // ========== CONSTRUCTOR ==========\r\n    /**\r\n     * @notice Initializes the vesting contract\r\n     * @param _equorumToken Address of the Equorum token\r\n     * @param _genesisAddress Address of the Genesis beneficiary\r\n     * @dev Does NOT require tokens at deploy time - use isFunded() to verify before release\r\n     */\r\n    constructor(address _equorumToken, address _genesisAddress) {\r\n        if (_equorumToken == address(0)) revert InvalidAddress();\r\n        if (_genesisAddress == address(0)) revert InvalidAddress();\r\n        \r\n        equorumToken = IERC20(_equorumToken);\r\n        genesisAddress = _genesisAddress;\r\n        releaseStartTime = block.timestamp;\r\n    }\r\n    \r\n    // ========== VESTING FUNCTIONS ==========\r\n\r\n    /**\r\n     * @notice Releases all vested tokens available up to current time\r\n     * @dev Can be called anytime by Genesis address\r\n     * @dev Automatically catches up if multiple months were missed\r\n     * @dev Protected against double claims by releasedTokens tracking\r\n     */\r\n    function release() external nonReentrant onlyGenesis {\r\n        uint256 releasable = calculateReleasableAmount();\r\n        if (releasable == 0) revert NoTokensToRelease();\r\n        \r\n        uint256 monthsPassed = (block.timestamp - releaseStartTime) / SECONDS_PER_MONTH;\r\n        if (monthsPassed > VESTING_DURATION) {\r\n            monthsPassed = VESTING_DURATION;\r\n        }\r\n        \r\n        releasedTokens += releasable;\r\n        lastReleaseTimestamp = block.timestamp;\r\n        \r\n        if (!equorumToken.transfer(genesisAddress, releasable)) revert TransferFailed();\r\n        \r\n        emit TokensReleased(genesisAddress, releasable, monthsPassed, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Calculates the amount of tokens that can be released\r\n     * @return uint256 Amount of releasable tokens\r\n     * @dev Returns 0 if vesting hasn't started\r\n     * @dev Ensures total released never exceeds GENESIS_ALLOCATION\r\n     */\r\n    function calculateReleasableAmount() public view returns (uint256) {\r\n        if (block.timestamp < releaseStartTime) {\r\n            return 0;\r\n        }\r\n        \r\n        uint256 elapsedMonths = (block.timestamp - releaseStartTime) / SECONDS_PER_MONTH;\r\n        \r\n        // If vesting is complete, release remaining tokens\r\n        if (elapsedMonths >= VESTING_DURATION) {\r\n            return GENESIS_ALLOCATION - releasedTokens;\r\n        }\r\n        \r\n        // Calculate total that should be released by now\r\n        uint256 totalToRelease = elapsedMonths * MONTHLY_RELEASE;\r\n        \r\n        // Calculate claimable amount\r\n        uint256 claimable = totalToRelease - releasedTokens;\r\n        \r\n        // Ensure we never exceed total allocation\r\n        uint256 remaining = GENESIS_ALLOCATION - releasedTokens;\r\n        return claimable > remaining ? remaining : claimable;\r\n    }\r\n    \r\n    // ========== VIEW FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Returns complete vesting information\r\n     * @return total Total allocation\r\n     * @return released Tokens already released\r\n     * @return remaining Tokens still locked\r\n     * @return monthlyAmount Monthly release amount\r\n     * @return nextRelease Amount available for next release\r\n     * @return monthsElapsed Months elapsed since start\r\n     * @return monthsRemaining Months remaining in vesting\r\n     */\r\n    function getVestingInfo() external view returns (\r\n        uint256 total,\r\n        uint256 released,\r\n        uint256 remaining,\r\n        uint256 monthlyAmount,\r\n        uint256 nextRelease,\r\n        uint256 monthsElapsed,\r\n        uint256 monthsRemaining\r\n    ) {\r\n        total = GENESIS_ALLOCATION;\r\n        released = releasedTokens;\r\n        remaining = GENESIS_ALLOCATION - releasedTokens;\r\n        monthlyAmount = MONTHLY_RELEASE;\r\n        nextRelease = calculateReleasableAmount();\r\n        \r\n        monthsElapsed = (block.timestamp - releaseStartTime) / SECONDS_PER_MONTH;\r\n        if (monthsElapsed > VESTING_DURATION) {\r\n            monthsElapsed = VESTING_DURATION;\r\n        }\r\n        \r\n        monthsRemaining = monthsElapsed >= VESTING_DURATION \r\n            ? 0 \r\n            : VESTING_DURATION - monthsElapsed;\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns the current contract token balance\r\n     * @return uint256 Current balance of tokens in contract\r\n     * @dev Useful for monitoring and verification\r\n     */\r\n    function getContractBalance() external view returns (uint256) {\r\n        return equorumToken.balanceOf(address(this));\r\n    }\r\n    \r\n    /**\r\n     * @notice Checks if contract has sufficient tokens for vesting\r\n     * @return bool True if contract has at least GENESIS_ALLOCATION tokens\r\n     * @dev Call this off-chain before first release to verify funding\r\n     */\r\n    function isFunded() external view returns (bool) {\r\n        return equorumToken.balanceOf(address(this)) >= GENESIS_ALLOCATION - releasedTokens;\r\n    }\r\n}\r\n"
    },
    "contracts/EquorumGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"./TimeLock.sol\";\r\n\r\n/**\r\n * @title EquorumGovernance\r\n * @notice On-chain governance with QUADRATIC VOTING by LOCK (stake-to-vote)\r\n * @dev Optimized for Arbitrum L2 with efficient storage and gas patterns\r\n * \r\n * FEATURES:\r\n * - Proposal threshold: 10,000 EQM (locked)\r\n * - Voting period: 7 days\r\n * - Quorum: 4% of total supply (quadratic)  1385 votes\r\n * - **QUADRATIC VOTING: sqrt(locked tokens) = votes** (protects against whales)\r\n * - Execution via TimeLock (48h delay)\r\n * \r\n * ANTI-SYBIL PROTECTIONS:\r\n * - Vote by LOCK: tokens must be locked to vote (prevents flash loan attacks)\r\n * - Lock age requirement: 7 days minimum lock before voting\r\n * - Minimum lock: 100 EQM to participate\r\n * - unlockAfter tracking: user cannot unlock until ALL voted proposals end\r\n * \r\n * QUADRATIC VOTING (NORMALIZED):\r\n * - Voting power = sqrt(lockedTokens / 1e18) in human-readable units\r\n * - Example: 10,000 EQM locked = sqrt(10000) = 100 votes\r\n * - Example: 1,000,000 EQM locked = sqrt(1000000) = 1000 votes\r\n * - Quorum = sqrt(4% of totalSupply / 1e18)  1385 votes\r\n * \r\n * LOCK AGE TRADEOFF (DOCUMENTED):\r\n * - lockTime is set on FIRST lock only (not reset when adding more tokens)\r\n * - This means: user can lock 100 EQM, wait 7 days, then add 1M EQM and vote immediately\r\n * - Tradeoff: Better UX (can add tokens without resetting age) vs. slightly weaker anti-sybil\r\n * - Mitigation: The 7-day lock requirement still prevents flash attacks\r\n * \r\n * GENESIS RESTRICTIONS:\r\n * - Genesis vesting contract CANNOT vote\r\n * - Genesis vesting contract CANNOT create proposals\r\n * \r\n * ARBITRUM L2 OPTIMIZATIONS:\r\n * - Compact storage layout\r\n * - Efficient vote counting\r\n * - Gas-optimized square root calculation\r\n */\r\ncontract EquorumGovernance is ReentrancyGuard {\r\n    \r\n    // ========== CUSTOM ERRORS ==========\r\n    error InvalidAddress();\r\n    error GenesisCannotParticipate();\r\n    error BelowProposalThreshold();\r\n    error MustProvideActions();\r\n    error ArrayLengthMismatch();\r\n    error EmptyDescription();\r\n    error VotingClosed();\r\n    error AlreadyVoted();\r\n    error NoVotingPower();\r\n    error ProposalNotSucceeded();\r\n    error ProposalNotQueued();\r\n    error OnlyProposerCanCancel();\r\n    error CannotCancelExecuted();\r\n    error InvalidProposal();\r\n    error InsufficientLock();\r\n    error LockTooNew();\r\n    error NoLockFound();\r\n    error LockStillActive();\r\n    error TransferFailed();\r\n    error BelowMinimumLock();\r\n    error AlreadyQueued();\r\n    error InvalidValue();\r\n    \r\n    // ========== CONSTANTS ==========\r\n    uint256 public constant PROPOSAL_THRESHOLD = 10_000 * 1e18;  // 10K EQM locked\r\n    uint256 public constant VOTING_PERIOD = 7 days;\r\n    uint256 public constant QUORUM_PERCENTAGE = 400;  // 4% (base 10000)\r\n    uint256 public constant MIN_LOCK_AMOUNT = 100 * 1e18;  // 100 EQM minimum to vote\r\n    uint256 public constant MIN_LOCK_AGE = 7 days;  // Must be locked 7 days before voting\r\n    \r\n    // ========== STATE VARIABLES ==========\r\n    IERC20 public immutable equorumToken;\r\n    TimeLock public immutable timeLock;\r\n    address public immutable genesisVesting;\r\n    \r\n    uint256 public proposalCount;\r\n    \r\n    // ========== LOCK SYSTEM (stake-to-vote) ==========\r\n    struct Lock {\r\n        uint256 amount;\r\n        uint256 lockTime;      // When tokens were locked\r\n    }\r\n    \r\n    mapping(address => Lock) public locks;\r\n    mapping(address => uint256) public unlockAfter;  // Timestamp when user can unlock (max endTime of voted proposals)\r\n    uint256 public totalLocked;\r\n    \r\n    // ========== PROPOSAL SYSTEM ==========\r\n    enum ProposalState {\r\n        Pending,\r\n        Active,\r\n        Defeated,\r\n        Succeeded,\r\n        Queued,\r\n        Executed,\r\n        Canceled,\r\n        Expired      // NEW: Proposal expired in timelock (past eta + GRACE_PERIOD)\r\n    }\r\n    \r\n    struct Proposal {\r\n        uint256 id;\r\n        address proposer;\r\n        string description;\r\n        address[] targets;\r\n        uint256[] values;\r\n        string[] signatures;\r\n        bytes[] calldatas;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 forVotes;\r\n        uint256 againstVotes;\r\n        bool executed;\r\n        bool canceled;\r\n        bool queued;           // CRITICAL: Track if proposal is queued\r\n        uint256 eta;           // CRITICAL: Store ETA for timelock execution\r\n        mapping(address => bool) hasVoted;\r\n        mapping(address => uint256) voteSnapshot;  // Snapshot of locked amount at vote time\r\n    }\r\n    \r\n    mapping(uint256 => Proposal) public proposals;\r\n    \r\n    // ========== EVENTS ==========\r\n    event ProposalCreated(\r\n        uint256 indexed proposalId,\r\n        address indexed proposer,\r\n        string description,\r\n        uint256 startTime,\r\n        uint256 endTime\r\n    );\r\n    \r\n    event VoteCast(\r\n        uint256 indexed proposalId,\r\n        address indexed voter,\r\n        bool support,\r\n        uint256 weight\r\n    );\r\n    \r\n    event ProposalQueued(uint256 indexed proposalId, uint256 eta);\r\n    event ProposalExecuted(uint256 indexed proposalId);\r\n    event ProposalCanceled(uint256 indexed proposalId);\r\n    \r\n    // Lock events\r\n    event TokensLocked(address indexed user, uint256 amount, uint256 totalLocked);\r\n    event TokensUnlocked(address indexed user, uint256 amount);\r\n    \r\n    // ========== CONSTRUCTOR ==========\r\n    /**\r\n     * @param _equorumToken Address of the EQM token\r\n     * @param _timeLock Address of the TimeLock contract\r\n     * @param _genesisVesting Address of Genesis vesting contract (excluded from voting)\r\n     */\r\n    constructor(address _equorumToken, address _timeLock, address _genesisVesting) {\r\n        if (_equorumToken == address(0)) revert InvalidAddress();\r\n        if (_timeLock == address(0)) revert InvalidAddress();\r\n        if (_genesisVesting == address(0)) revert InvalidAddress();\r\n        \r\n        equorumToken = IERC20(_equorumToken);\r\n        timeLock = TimeLock(payable(_timeLock));\r\n        genesisVesting = _genesisVesting;\r\n    }\r\n    \r\n    // ========== LOCK FUNCTIONS (stake-to-vote) ==========\r\n    \r\n    /**\r\n     * @notice Lock tokens to participate in governance\r\n     * @param amount Amount of EQM to lock\r\n     * @dev Tokens must be locked for MIN_LOCK_AGE before voting\r\n     * @dev Genesis vesting contract cannot lock\r\n     */\r\n    function lock(uint256 amount) external nonReentrant {\r\n        if (msg.sender == genesisVesting) revert GenesisCannotParticipate();\r\n        if (amount < MIN_LOCK_AMOUNT) revert BelowMinimumLock();\r\n        \r\n        Lock storage userLock = locks[msg.sender];\r\n        \r\n        // If first lock or adding to existing lock\r\n        if (userLock.amount == 0) {\r\n            userLock.lockTime = block.timestamp;\r\n        }\r\n        \r\n        userLock.amount += amount;\r\n        totalLocked += amount;\r\n        \r\n        // Transfer tokens to this contract\r\n        if (!equorumToken.transferFrom(msg.sender, address(this), amount)) revert TransferFailed();\r\n        \r\n        emit TokensLocked(msg.sender, amount, userLock.amount);\r\n    }\r\n    \r\n    /**\r\n     * @notice Unlock tokens after all voted proposals have ended\r\n     * @dev Uses unlockAfter timestamp (max endTime of all voted proposals)\r\n     */\r\n    function unlock() external nonReentrant {\r\n        Lock storage userLock = locks[msg.sender];\r\n        if (userLock.amount == 0) revert NoLockFound();\r\n        \r\n        // CRITICAL: Check against unlockAfter (max endTime of all voted proposals)\r\n        if (block.timestamp < unlockAfter[msg.sender]) revert LockStillActive();\r\n        \r\n        uint256 amount = userLock.amount;\r\n        \r\n        // Clear lock and unlockAfter\r\n        userLock.amount = 0;\r\n        userLock.lockTime = 0;\r\n        unlockAfter[msg.sender] = 0;\r\n        totalLocked -= amount;\r\n        \r\n        // Transfer tokens back\r\n        if (!equorumToken.transfer(msg.sender, amount)) revert TransferFailed();\r\n        \r\n        emit TokensUnlocked(msg.sender, amount);\r\n    }\r\n    \r\n    // ========== PROPOSAL FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Creates a new proposal\r\n     * @param targets Target contract addresses\r\n     * @param values ETH values for each call\r\n     * @param signatures Function signatures\r\n     * @param calldatas Call data\r\n     * @param description Proposal description\r\n     * @dev Genesis vesting contract cannot create proposals\r\n     * @dev Proposer must have PROPOSAL_THRESHOLD locked tokens\r\n     */\r\n    function propose(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        string[] memory signatures,\r\n        bytes[] memory calldatas,\r\n        string memory description\r\n    ) external nonReentrant returns (uint256) {\r\n        if (msg.sender == genesisVesting) revert GenesisCannotParticipate();\r\n        \r\n        Lock storage userLock = locks[msg.sender];\r\n        if (userLock.amount < PROPOSAL_THRESHOLD) revert BelowProposalThreshold();\r\n        if (block.timestamp < userLock.lockTime + MIN_LOCK_AGE) revert LockTooNew();\r\n        \r\n        if (targets.length == 0) revert MustProvideActions();\r\n        if (targets.length != values.length) revert ArrayLengthMismatch();\r\n        if (targets.length != signatures.length) revert ArrayLengthMismatch();\r\n        if (targets.length != calldatas.length) revert ArrayLengthMismatch();\r\n        if (bytes(description).length == 0) revert EmptyDescription();\r\n        \r\n        uint256 proposalId = ++proposalCount;\r\n        Proposal storage newProposal = proposals[proposalId];\r\n        \r\n        newProposal.id = proposalId;\r\n        newProposal.proposer = msg.sender;\r\n        newProposal.description = description;\r\n        newProposal.targets = targets;\r\n        newProposal.values = values;\r\n        newProposal.signatures = signatures;\r\n        newProposal.calldatas = calldatas;\r\n        newProposal.startTime = block.timestamp;\r\n        newProposal.endTime = block.timestamp + VOTING_PERIOD;\r\n        \r\n        emit ProposalCreated(\r\n            proposalId,\r\n            msg.sender,\r\n            description,\r\n            newProposal.startTime,\r\n            newProposal.endTime\r\n        );\r\n        \r\n        return proposalId;\r\n    }\r\n    \r\n    /**\r\n     * @notice Votes on a proposal with QUADRATIC VOTING by LOCK\r\n     * @param proposalId Proposal ID\r\n     * @param support true = for, false = against\r\n     * @dev Genesis vesting contract cannot vote\r\n     * @dev Voting power = sqrt(locked tokens) - QUADRATIC VOTING\r\n     * @dev Tokens must be locked for MIN_LOCK_AGE before voting\r\n     */\r\n    function castVote(uint256 proposalId, bool support) external nonReentrant {\r\n        if (state(proposalId) != ProposalState.Active) revert VotingClosed();\r\n        if (msg.sender == genesisVesting) revert GenesisCannotParticipate();\r\n        \r\n        Proposal storage proposal = proposals[proposalId];\r\n        if (proposal.hasVoted[msg.sender]) revert AlreadyVoted();\r\n        \r\n        Lock storage userLock = locks[msg.sender];\r\n        if (userLock.amount == 0) revert NoVotingPower();\r\n        if (userLock.amount < MIN_LOCK_AMOUNT) revert InsufficientLock();\r\n        \r\n        // ANTI-SYBIL: Lock must be old enough (prevents flash attacks)\r\n        if (block.timestamp < userLock.lockTime + MIN_LOCK_AGE) revert LockTooNew();\r\n        \r\n        // QUADRATIC VOTING: sqrt(locked amount / 1e18) = voting power in human-readable units\r\n        // Example: 10,000 locked tokens = sqrt(10000) = 100 votes\r\n        uint256 weight = _sqrt(userLock.amount / 1e18);\r\n        \r\n        // Record vote\r\n        proposal.hasVoted[msg.sender] = true;\r\n        proposal.voteSnapshot[msg.sender] = userLock.amount;  // Snapshot for records\r\n        \r\n        // CRITICAL: Update unlockAfter to max(current, proposal.endTime)\r\n        // This ensures user cannot unlock until ALL voted proposals have ended\r\n        if (proposal.endTime > unlockAfter[msg.sender]) {\r\n            unlockAfter[msg.sender] = proposal.endTime;\r\n        }\r\n        \r\n        if (support) {\r\n            proposal.forVotes += weight;\r\n        } else {\r\n            proposal.againstVotes += weight;\r\n        }\r\n        \r\n        emit VoteCast(proposalId, msg.sender, support, weight);\r\n    }\r\n    \r\n    /**\r\n     * @notice Queue approved proposal to TimeLock\r\n     * @param proposalId Proposal ID\r\n     * @dev Stores ETA for later execution\r\n     */\r\n    function queue(uint256 proposalId) external nonReentrant {\r\n        if (state(proposalId) != ProposalState.Succeeded) revert ProposalNotSucceeded();\r\n        \r\n        Proposal storage proposal = proposals[proposalId];\r\n        \r\n        // CRITICAL: Prevent double queue\r\n        if (proposal.queued) revert AlreadyQueued();\r\n        \r\n        uint256 eta = block.timestamp + timeLock.DELAY();\r\n        \r\n        // CRITICAL: Store queued state and ETA\r\n        proposal.queued = true;\r\n        proposal.eta = eta;\r\n        \r\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n            timeLock.queueTransaction(\r\n                proposal.targets[i],\r\n                proposal.values[i],\r\n                proposal.signatures[i],\r\n                proposal.calldatas[i],\r\n                eta\r\n            );\r\n        }\r\n        \r\n        emit ProposalQueued(proposalId, eta);\r\n    }\r\n    \r\n    /**\r\n     * @notice Execute proposal after TimeLock delay\r\n     * @param proposalId Proposal ID\r\n     * @dev Uses stored proposal.eta (not block.timestamp)\r\n     * @dev Sets executed=true AFTER successful execution\r\n     * @dev Requires msg.value == sum of all proposal values\r\n     */\r\n    function execute(uint256 proposalId) external payable nonReentrant {\r\n        if (state(proposalId) != ProposalState.Queued) revert ProposalNotQueued();\r\n        \r\n        Proposal storage proposal = proposals[proposalId];\r\n        \r\n        // CRITICAL: Validate msg.value matches total required ETH\r\n        // With overflow protection for malicious proposals\r\n        uint256 totalValue = 0;\r\n        for (uint256 i = 0; i < proposal.values.length; i++) {\r\n            uint256 v = proposal.values[i];\r\n            if (totalValue > type(uint256).max - v) revert InvalidValue();\r\n            totalValue += v;\r\n        }\r\n        if (msg.value != totalValue) revert InvalidValue();\r\n        \r\n        // CRITICAL: Use stored ETA, not block.timestamp\r\n        uint256 eta = proposal.eta;\r\n        \r\n        // Execute all transactions\r\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n            timeLock.executeTransaction{value: proposal.values[i]}(\r\n                proposal.targets[i],\r\n                proposal.values[i],\r\n                proposal.signatures[i],\r\n                proposal.calldatas[i],\r\n                eta\r\n            );\r\n        }\r\n        \r\n        // CRITICAL: Set executed AFTER successful execution (not before)\r\n        proposal.executed = true;\r\n        \r\n        emit ProposalExecuted(proposalId);\r\n    }\r\n    \r\n    /**\r\n     * @notice Cancel a proposal\r\n     * @param proposalId Proposal ID\r\n     * @dev Also cancels queued transactions in timelock if queued\r\n     */\r\n    function cancel(uint256 proposalId) external {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        if (msg.sender != proposal.proposer) revert OnlyProposerCanCancel();\r\n        if (state(proposalId) == ProposalState.Executed) revert CannotCancelExecuted();\r\n        \r\n        // If queued, cancel transactions in timelock\r\n        if (proposal.queued && !proposal.executed) {\r\n            uint256 eta = proposal.eta;\r\n            for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n                timeLock.cancelTransaction(\r\n                    proposal.targets[i],\r\n                    proposal.values[i],\r\n                    proposal.signatures[i],\r\n                    proposal.calldatas[i],\r\n                    eta\r\n                );\r\n            }\r\n            // CRITICAL: Clear queued state for hygiene\r\n            proposal.queued = false;\r\n            proposal.eta = 0;\r\n        }\r\n        \r\n        proposal.canceled = true;\r\n        \r\n        emit ProposalCanceled(proposalId);\r\n    }\r\n    \r\n    // ========== VIEW FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Returns the current state of a proposal\r\n     * @dev Integrates with TimeLock GRACE_PERIOD for Expired state\r\n     */\r\n    function state(uint256 proposalId) public view returns (ProposalState) {\r\n        if (proposalId == 0 || proposalId > proposalCount) revert InvalidProposal();\r\n        \r\n        Proposal storage proposal = proposals[proposalId];\r\n        \r\n        // Check terminal states first\r\n        if (proposal.canceled) {\r\n            return ProposalState.Canceled;\r\n        }\r\n        \r\n        if (proposal.executed) {\r\n            return ProposalState.Executed;\r\n        }\r\n        \r\n        // CRITICAL: Check if queued and handle timelock expiration\r\n        if (proposal.queued) {\r\n            // Check if proposal expired in timelock (past eta + GRACE_PERIOD)\r\n            if (block.timestamp > proposal.eta + timeLock.GRACE_PERIOD()) {\r\n                return ProposalState.Expired;\r\n            }\r\n            return ProposalState.Queued;\r\n        }\r\n        \r\n        // Check if voting is still active\r\n        if (block.timestamp < proposal.endTime) {\r\n            return ProposalState.Active;\r\n        }\r\n        \r\n        // Voting ended - check quorum and approval\r\n        uint256 totalVotes = proposal.forVotes + proposal.againstVotes;\r\n        \r\n        // Quorum is quadratic: sqrt(4% of total supply / 1e18) in human-readable units\r\n        // Example: 4% of 48M = 1.92M tokens, sqrt(1920000)  1385 votes\r\n        uint256 linearQuorum = (equorumToken.totalSupply() * QUORUM_PERCENTAGE) / 10000;\r\n        uint256 requiredQuorum = _sqrt(linearQuorum / 1e18);\r\n        \r\n        if (totalVotes < requiredQuorum) {\r\n            return ProposalState.Defeated;\r\n        }\r\n        \r\n        if (proposal.forVotes > proposal.againstVotes) {\r\n            return ProposalState.Succeeded;\r\n        }\r\n        \r\n        return ProposalState.Defeated;\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns proposal information\r\n     */\r\n    function getProposalInfo(uint256 proposalId) external view returns (\r\n        address proposer,\r\n        string memory description,\r\n        uint256 forVotes,\r\n        uint256 againstVotes,\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        bool executed,\r\n        bool canceled,\r\n        ProposalState currentState\r\n    ) {\r\n        if (proposalId == 0 || proposalId > proposalCount) revert InvalidProposal();\r\n        \r\n        Proposal storage proposal = proposals[proposalId];\r\n        \r\n        return (\r\n            proposal.proposer,\r\n            proposal.description,\r\n            proposal.forVotes,\r\n            proposal.againstVotes,\r\n            proposal.startTime,\r\n            proposal.endTime,\r\n            proposal.executed,\r\n            proposal.canceled,\r\n            state(proposalId)\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @notice Check if address has voted on proposal\r\n     */\r\n    function hasVoted(uint256 proposalId, address voter) external view returns (bool) {\r\n        return proposals[proposalId].hasVoted[voter];\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns proposal actions\r\n     */\r\n    function getActions(uint256 proposalId) external view returns (\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        string[] memory signatures,\r\n        bytes[] memory calldatas\r\n    ) {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        return (\r\n            proposal.targets,\r\n            proposal.values,\r\n            proposal.signatures,\r\n            proposal.calldatas\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @notice Calculate required quorum (quadratic, human-readable)\r\n     * @dev With quadratic voting, quorum is sqrt(4% of supply / 1e18)\r\n     * @return Required quorum in human-readable vote units (e.g., 1385 votes)\r\n     */\r\n    function quorum() public view returns (uint256) {\r\n        uint256 linearQuorum = (equorumToken.totalSupply() * QUORUM_PERCENTAGE) / 10000;\r\n        return _sqrt(linearQuorum / 1e18);\r\n    }\r\n    \r\n    /**\r\n     * @notice Calculate quadratic voting power for an address based on LOCKED tokens\r\n     * @param account Address to check\r\n     * @return votingPower Quadratic voting power in human-readable units (e.g., 100 votes for 10K tokens)\r\n     * @return canVote Whether the user can currently vote (has lock, lock is old enough)\r\n     */\r\n    function getVotingPower(address account) external view returns (uint256 votingPower, bool canVote) {\r\n        Lock storage userLock = locks[account];\r\n        \r\n        if (userLock.amount == 0) {\r\n            return (0, false);\r\n        }\r\n        \r\n        // Normalize by 1e18 for human-readable vote units\r\n        votingPower = _sqrt(userLock.amount / 1e18);\r\n        canVote = userLock.amount >= MIN_LOCK_AMOUNT && \r\n                  block.timestamp >= userLock.lockTime + MIN_LOCK_AGE;\r\n    }\r\n    \r\n    /**\r\n     * @notice Get lock information for an address\r\n     * @param account Address to check\r\n     */\r\n    function getLockInfo(address account) external view returns (\r\n        uint256 amount,\r\n        uint256 lockTime,\r\n        uint256 votingPower,\r\n        bool canVote,\r\n        bool canUnlock\r\n    ) {\r\n        Lock storage userLock = locks[account];\r\n        \r\n        amount = userLock.amount;\r\n        lockTime = userLock.lockTime;\r\n        // Normalize by 1e18 for human-readable vote units\r\n        votingPower = userLock.amount > 0 ? _sqrt(userLock.amount / 1e18) : 0;\r\n        canVote = userLock.amount >= MIN_LOCK_AMOUNT && \r\n                  block.timestamp >= userLock.lockTime + MIN_LOCK_AGE;\r\n        \r\n        // Check if can unlock using unlockAfter timestamp\r\n        canUnlock = userLock.amount > 0 && block.timestamp >= unlockAfter[account];\r\n    }\r\n    \r\n    /**\r\n     * @notice Get proposal ETA (for queued proposals)\r\n     */\r\n    function getProposalEta(uint256 proposalId) external view returns (uint256) {\r\n        return proposals[proposalId].eta;\r\n    }\r\n    \r\n    /**\r\n     * @notice Get unlock timestamp for an address\r\n     * @param account Address to check\r\n     * @return Timestamp when user can unlock (0 if no active votes)\r\n     */\r\n    function getUnlockAfter(address account) external view returns (uint256) {\r\n        return unlockAfter[account];\r\n    }\r\n    \r\n    /**\r\n     * @notice Check if a queued proposal is executable (ETA reached but not expired)\r\n     * @param proposalId Proposal ID\r\n     * @return True if proposal can be executed now\r\n     */\r\n    function isExecutable(uint256 proposalId) external view returns (bool) {\r\n        if (proposalId == 0 || proposalId > proposalCount) return false;\r\n        \r\n        Proposal storage proposal = proposals[proposalId];\r\n        \r\n        // Must be queued, not executed, not canceled\r\n        if (!proposal.queued || proposal.executed || proposal.canceled) return false;\r\n        \r\n        // Must be past ETA but within grace period\r\n        uint256 eta = proposal.eta;\r\n        return block.timestamp >= eta && block.timestamp <= eta + timeLock.GRACE_PERIOD();\r\n    }\r\n    \r\n    /**\r\n     * @notice Mark an expired proposal as no longer queued (cleanup function)\r\n     * @param proposalId Proposal ID\r\n     * @dev Anyone can call this to clean up expired proposals\r\n     */\r\n    function markExpired(uint256 proposalId) external {\r\n        if (state(proposalId) != ProposalState.Expired) revert ProposalNotQueued();\r\n        \r\n        Proposal storage proposal = proposals[proposalId];\r\n        proposal.queued = false;\r\n        proposal.eta = 0;\r\n    }\r\n    \r\n    // ========== INTERNAL FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Efficient square root calculation (Babylonian method)\r\n     * @dev Optimized for Arbitrum L2\r\n     * @param x Number to calculate square root of\r\n     * @return y Square root of x\r\n     */\r\n    function _sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        if (x == 0) return 0;\r\n        \r\n        // Initial guess (using bit shifting for efficiency)\r\n        uint256 z = (x + 1) / 2;\r\n        y = x;\r\n        \r\n        // Babylonian method (Newton's method for square roots)\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/EquorumICO.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title EquorumICO\r\n * @notice ICO contract for Equorum token with private and public sale phases\r\n * @dev Optimized for Arbitrum L2 with vesting and security features\r\n * \r\n * FEATURES:\r\n * - Two-phase sale: Private (20%) and Public (80%)\r\n * - Vesting schedules for both phases\r\n * - Whitelist for private sale\r\n * - Per-user purchase limits\r\n * - Soft/Hard caps\r\n * - Emergency pause functionality\r\n * - Refund mechanism if soft cap not reached\r\n * \r\n * ARBITRUM L2 OPTIMIZATIONS:\r\n * - Compact storage layout\r\n * - Minimal SLOAD operations\r\n * - Gas-efficient vesting calculations\r\n */\r\ncontract EquorumICO is Ownable, Pausable, ReentrancyGuard {\r\n    \r\n    // ========== CONSTANTS ==========\r\n    \r\n    /// @notice Total ICO allocation (received from EquorumToken)\r\n    uint256 public constant TOTAL_ALLOCATION = 4_000_000 * 1e18;\r\n    \r\n    /// @notice Private sale allocation (20% of ICO)\r\n    uint256 public constant PRIVATE_SALE_ALLOCATION = 800_000 * 1e18;\r\n    \r\n    /// @notice Public sale allocation (80% of ICO)\r\n    uint256 public constant PUBLIC_SALE_ALLOCATION = 3_200_000 * 1e18;\r\n    \r\n    /// @notice Private sale price: $0.20 per token (0.0001 ETH @ $2000 ETH)\r\n    uint256 public constant PRIVATE_SALE_PRICE = 0.0001 ether;\r\n    \r\n    /// @notice Public sale price: $0.30 per token (50% premium)\r\n    uint256 public constant PUBLIC_SALE_PRICE = 0.00015 ether;\r\n    \r\n    /// @notice Private sale vesting: 3 months cliff + 12 months linear\r\n    uint256 public constant PRIVATE_CLIFF = 90 days;\r\n    uint256 public constant PRIVATE_VESTING_DURATION = 365 days;\r\n    \r\n    /// @notice Public sale vesting: 1 month cliff + 6 months linear\r\n    uint256 public constant PUBLIC_CLIFF = 30 days;\r\n    uint256 public constant PUBLIC_VESTING_DURATION = 180 days;\r\n    \r\n    /// @notice Purchase limits for private sale\r\n    uint256 public constant PRIVATE_MIN_PURCHASE = 0.1 ether;   // ~$200\r\n    uint256 public constant PRIVATE_MAX_PURCHASE = 5 ether;     // ~$10K\r\n    \r\n    /// @notice Purchase limits for public sale\r\n    uint256 public constant PUBLIC_MIN_PURCHASE = 0.01 ether;   // ~$20\r\n    uint256 public constant PUBLIC_MAX_PURCHASE = 1 ether;      // ~$2K\r\n    \r\n    /// @notice Soft and hard caps for public sale\r\n    uint256 public constant SOFT_CAP = 100 ether;   // ~$200K\r\n    uint256 public constant HARD_CAP = 500 ether;   // ~$1M\r\n    \r\n    // ========== ENUMS ==========\r\n    \r\n    enum SalePhase { NOT_STARTED, PRIVATE, PUBLIC, ENDED }\r\n    \r\n    // ========== STRUCTS ==========\r\n    \r\n    /// @notice Vesting information for each investor\r\n    struct VestingInfo {\r\n        uint256 totalAmount;        // Total tokens purchased\r\n        uint256 claimedAmount;      // Tokens already claimed\r\n        uint256 startTime;          // Vesting start time\r\n        uint256 cliffDuration;      // Cliff period\r\n        uint256 vestingDuration;    // Total vesting duration\r\n        bool isPrivateSale;         // True if private sale investor\r\n    }\r\n    \r\n    // ========== STATE VARIABLES ==========\r\n    \r\n    /// @notice EQM token contract\r\n    IERC20 public immutable equorumToken;\r\n    \r\n    /// @notice Current sale phase\r\n    SalePhase public currentPhase;\r\n    \r\n    /// @notice Whitelist for private sale\r\n    mapping(address => bool) public whitelisted;\r\n    \r\n    /// @notice ETH contributed by each investor\r\n    mapping(address => uint256) public contributions;\r\n    \r\n    /// @notice Vesting information for each investor\r\n    mapping(address => VestingInfo) public vestingInfo;\r\n    \r\n    /// @notice Total ETH raised\r\n    uint256 public totalRaised;\r\n    \r\n    /// @notice Total tokens sold\r\n    uint256 public totalTokensSold;\r\n    \r\n    /// @notice Private sale tokens sold\r\n    uint256 public privateSaleTokensSold;\r\n    \r\n    /// @notice Public sale tokens sold\r\n    uint256 public publicSaleTokensSold;\r\n    \r\n    /// @notice Sale start times\r\n    uint256 public privateSaleStartTime;\r\n    uint256 public publicSaleStartTime;\r\n    \r\n    /// @notice Refund enabled if soft cap not reached\r\n    bool public refundEnabled;\r\n    \r\n    // ========== EVENTS ==========\r\n    \r\n    event PrivateSaleStarted(uint256 timestamp);\r\n    event PublicSaleStarted(uint256 timestamp);\r\n    event SaleEnded(uint256 timestamp, uint256 totalRaised, uint256 totalTokensSold);\r\n    event TokensPurchased(address indexed buyer, uint256 ethAmount, uint256 tokenAmount, bool isPrivateSale);\r\n    event TokensClaimed(address indexed investor, uint256 amount);\r\n    event WhitelistAdded(address indexed investor);\r\n    event WhitelistRemoved(address indexed investor);\r\n    event RefundClaimed(address indexed investor, uint256 amount);\r\n    event FundsWithdrawn(address indexed owner, uint256 amount);\r\n    \r\n    // ========== CONSTRUCTOR ==========\r\n    \r\n    /**\r\n     * @notice Initialize ICO contract\r\n     * @param _equorumToken Address of EQM token contract\r\n     * @dev Contract starts in NOT_STARTED phase\r\n     */\r\n    constructor(address _equorumToken) {\r\n        require(_equorumToken != address(0), \"Invalid token address\");\r\n        equorumToken = IERC20(_equorumToken);\r\n        currentPhase = SalePhase.NOT_STARTED;\r\n    }\r\n    \r\n    // ========== ADMIN FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Start private sale phase\r\n     * @dev Can only be called once, requires tokens in contract\r\n     */\r\n    function startPrivateSale() external onlyOwner {\r\n        require(currentPhase == SalePhase.NOT_STARTED, \"Sale already started\");\r\n        require(equorumToken.balanceOf(address(this)) >= TOTAL_ALLOCATION, \"Insufficient tokens\");\r\n        \r\n        currentPhase = SalePhase.PRIVATE;\r\n        privateSaleStartTime = block.timestamp;\r\n        \r\n        emit PrivateSaleStarted(block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Start public sale phase\r\n     * @dev Transitions from private to public sale\r\n     */\r\n    function startPublicSale() external onlyOwner {\r\n        require(currentPhase == SalePhase.PRIVATE, \"Private sale not active\");\r\n        \r\n        currentPhase = SalePhase.PUBLIC;\r\n        publicSaleStartTime = block.timestamp;\r\n        \r\n        emit PublicSaleStarted(block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice End the sale\r\n     * @dev Can be called by owner at any time\r\n     */\r\n    function endSale() external onlyOwner {\r\n        require(currentPhase != SalePhase.ENDED, \"Sale already ended\");\r\n        require(currentPhase != SalePhase.NOT_STARTED, \"Sale not started\");\r\n        \r\n        currentPhase = SalePhase.ENDED;\r\n        \r\n        // Enable refunds if soft cap not reached\r\n        if (totalRaised < SOFT_CAP) {\r\n            refundEnabled = true;\r\n        }\r\n        \r\n        emit SaleEnded(block.timestamp, totalRaised, totalTokensSold);\r\n    }\r\n    \r\n    /**\r\n     * @notice Add address to private sale whitelist\r\n     * @param investor Address to whitelist\r\n     */\r\n    function addToWhitelist(address investor) external onlyOwner {\r\n        require(investor != address(0), \"Invalid address\");\r\n        require(!whitelisted[investor], \"Already whitelisted\");\r\n        \r\n        whitelisted[investor] = true;\r\n        emit WhitelistAdded(investor);\r\n    }\r\n    \r\n    /**\r\n     * @notice Add multiple addresses to whitelist\r\n     * @param investors Array of addresses to whitelist\r\n     */\r\n    function batchAddToWhitelist(address[] calldata investors) external onlyOwner {\r\n        for (uint256 i = 0; i < investors.length; i++) {\r\n            if (investors[i] != address(0) && !whitelisted[investors[i]]) {\r\n                whitelisted[investors[i]] = true;\r\n                emit WhitelistAdded(investors[i]);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Remove address from whitelist\r\n     * @param investor Address to remove\r\n     */\r\n    function removeFromWhitelist(address investor) external onlyOwner {\r\n        require(whitelisted[investor], \"Not whitelisted\");\r\n        \r\n        whitelisted[investor] = false;\r\n        emit WhitelistRemoved(investor);\r\n    }\r\n    \r\n    /**\r\n     * @notice Withdraw raised funds\r\n     * @dev Only available after sale ends and soft cap reached\r\n     */\r\n    function withdrawFunds() external onlyOwner nonReentrant {\r\n        require(currentPhase == SalePhase.ENDED, \"Sale not ended\");\r\n        require(!refundEnabled, \"Refunds enabled\");\r\n        require(totalRaised >= SOFT_CAP, \"Soft cap not reached\");\r\n        \r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No funds to withdraw\");\r\n        \r\n        (bool success, ) = owner().call{value: balance}(\"\");\r\n        require(success, \"Transfer failed\");\r\n        \r\n        emit FundsWithdrawn(owner(), balance);\r\n    }\r\n    \r\n    /**\r\n     * @notice Withdraw unsold tokens\r\n     * @dev Only available after sale ends\r\n     */\r\n    function withdrawUnsoldTokens() external onlyOwner {\r\n        require(currentPhase == SalePhase.ENDED, \"Sale not ended\");\r\n        \r\n        uint256 unsold = equorumToken.balanceOf(address(this));\r\n        require(unsold > 0, \"No unsold tokens\");\r\n        \r\n        // Keep tokens for vesting, withdraw only truly unsold\r\n        uint256 vestedTokens = totalTokensSold;\r\n        uint256 toWithdraw = unsold > vestedTokens ? unsold - vestedTokens : 0;\r\n        \r\n        if (toWithdraw > 0) {\r\n            require(equorumToken.transfer(owner(), toWithdraw), \"Transfer failed\");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Pause purchases (emergency only)\r\n     */\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n    \r\n    /**\r\n     * @notice Resume purchases\r\n     */\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n    \r\n    // ========== PUBLIC FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Purchase tokens with ETH\r\n     * @dev Automatically determines phase and applies limits\r\n     */\r\n    function buyTokens() external payable nonReentrant whenNotPaused {\r\n        require(currentPhase == SalePhase.PRIVATE || currentPhase == SalePhase.PUBLIC, \"Sale not active\");\r\n        require(msg.value > 0, \"Must send ETH\");\r\n        \r\n        bool isPrivate = currentPhase == SalePhase.PRIVATE;\r\n        \r\n        // Check whitelist for private sale\r\n        if (isPrivate) {\r\n            require(whitelisted[msg.sender], \"Not whitelisted\");\r\n        }\r\n        \r\n        // Check purchase limits\r\n        uint256 minPurchase = isPrivate ? PRIVATE_MIN_PURCHASE : PUBLIC_MIN_PURCHASE;\r\n        uint256 maxPurchase = isPrivate ? PRIVATE_MAX_PURCHASE : PUBLIC_MAX_PURCHASE;\r\n        \r\n        require(msg.value >= minPurchase, \"Below minimum purchase\");\r\n        require(contributions[msg.sender] + msg.value <= maxPurchase, \"Exceeds maximum purchase\");\r\n        \r\n        // Calculate tokens\r\n        uint256 price = isPrivate ? PRIVATE_SALE_PRICE : PUBLIC_SALE_PRICE;\r\n        uint256 tokenAmount = (msg.value * 1e18) / price;\r\n        \r\n        // Check allocation limits\r\n        if (isPrivate) {\r\n            require(privateSaleTokensSold + tokenAmount <= PRIVATE_SALE_ALLOCATION, \"Private sale sold out\");\r\n            privateSaleTokensSold += tokenAmount;\r\n        } else {\r\n            require(publicSaleTokensSold + tokenAmount <= PUBLIC_SALE_ALLOCATION, \"Public sale sold out\");\r\n            require(totalRaised + msg.value <= HARD_CAP, \"Hard cap reached\");\r\n            publicSaleTokensSold += tokenAmount;\r\n        }\r\n        \r\n        // Update state\r\n        contributions[msg.sender] += msg.value;\r\n        totalRaised += msg.value;\r\n        totalTokensSold += tokenAmount;\r\n        \r\n        // Setup vesting\r\n        VestingInfo storage vesting = vestingInfo[msg.sender];\r\n        if (vesting.totalAmount == 0) {\r\n            // First purchase - initialize vesting\r\n            vesting.startTime = block.timestamp;\r\n            vesting.cliffDuration = isPrivate ? PRIVATE_CLIFF : PUBLIC_CLIFF;\r\n            vesting.vestingDuration = isPrivate ? PRIVATE_VESTING_DURATION : PUBLIC_VESTING_DURATION;\r\n            vesting.isPrivateSale = isPrivate;\r\n        }\r\n        vesting.totalAmount += tokenAmount;\r\n        \r\n        emit TokensPurchased(msg.sender, msg.value, tokenAmount, isPrivate);\r\n    }\r\n    \r\n    /**\r\n     * @notice Claim vested tokens\r\n     * @dev Calculates and transfers available vested tokens\r\n     */\r\n    function claimTokens() external nonReentrant {\r\n        VestingInfo storage vesting = vestingInfo[msg.sender];\r\n        require(vesting.totalAmount > 0, \"No tokens to claim\");\r\n        \r\n        uint256 claimable = calculateClaimableTokens(msg.sender);\r\n        require(claimable > 0, \"No tokens available\");\r\n        \r\n        vesting.claimedAmount += claimable;\r\n        require(equorumToken.transfer(msg.sender, claimable), \"Transfer failed\");\r\n        \r\n        emit TokensClaimed(msg.sender, claimable);\r\n    }\r\n    \r\n    /**\r\n     * @notice Claim refund if soft cap not reached\r\n     * @dev Only available if refunds are enabled\r\n     */\r\n    function claimRefund() external nonReentrant {\r\n        require(refundEnabled, \"Refunds not enabled\");\r\n        require(contributions[msg.sender] > 0, \"No contribution\");\r\n        \r\n        uint256 refundAmount = contributions[msg.sender];\r\n        contributions[msg.sender] = 0;\r\n        \r\n        // Clear vesting info\r\n        delete vestingInfo[msg.sender];\r\n        \r\n        (bool success, ) = msg.sender.call{value: refundAmount}(\"\");\r\n        require(success, \"Refund failed\");\r\n        \r\n        emit RefundClaimed(msg.sender, refundAmount);\r\n    }\r\n    \r\n    // ========== VIEW FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Calculate claimable tokens for an investor\r\n     * @param investor Address to check\r\n     * @return claimable Amount of tokens that can be claimed\r\n     */\r\n    function calculateClaimableTokens(address investor) public view returns (uint256 claimable) {\r\n        VestingInfo memory vesting = vestingInfo[investor];\r\n        \r\n        if (vesting.totalAmount == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        uint256 elapsed = block.timestamp - vesting.startTime;\r\n        \r\n        // Check if cliff has passed\r\n        if (elapsed < vesting.cliffDuration) {\r\n            return 0;\r\n        }\r\n        \r\n        // Calculate vested amount\r\n        uint256 vestedAmount;\r\n        if (elapsed >= vesting.cliffDuration + vesting.vestingDuration) {\r\n            // Fully vested\r\n            vestedAmount = vesting.totalAmount;\r\n        } else {\r\n            // Partially vested (linear)\r\n            uint256 vestingElapsed = elapsed - vesting.cliffDuration;\r\n            vestedAmount = (vesting.totalAmount * vestingElapsed) / vesting.vestingDuration;\r\n        }\r\n        \r\n        // Subtract already claimed\r\n        claimable = vestedAmount > vesting.claimedAmount ? vestedAmount - vesting.claimedAmount : 0;\r\n    }\r\n    \r\n    /**\r\n     * @notice Get investor information\r\n     * @param investor Address to check\r\n     * @return contribution ETH contributed\r\n     * @return totalTokens Total tokens purchased\r\n     * @return claimedTokens Tokens already claimed\r\n     * @return claimableTokens Tokens available to claim\r\n     * @return isWhitelisted Whitelist status\r\n     */\r\n    function getInvestorInfo(address investor) external view returns (\r\n        uint256 contribution,\r\n        uint256 totalTokens,\r\n        uint256 claimedTokens,\r\n        uint256 claimableTokens,\r\n        bool isWhitelisted\r\n    ) {\r\n        contribution = contributions[investor];\r\n        totalTokens = vestingInfo[investor].totalAmount;\r\n        claimedTokens = vestingInfo[investor].claimedAmount;\r\n        claimableTokens = calculateClaimableTokens(investor);\r\n        isWhitelisted = whitelisted[investor];\r\n    }\r\n    \r\n    /**\r\n     * @notice Get sale statistics\r\n     * @return phase Current sale phase\r\n     * @return raised Total ETH raised\r\n     * @return tokensSold Total tokens sold\r\n     * @return privateTokensSold Private sale tokens sold\r\n     * @return publicTokensSold Public sale tokens sold\r\n     */\r\n    function getSaleStats() external view returns (\r\n        SalePhase phase,\r\n        uint256 raised,\r\n        uint256 tokensSold,\r\n        uint256 privateTokensSold,\r\n        uint256 publicTokensSold\r\n    ) {\r\n        phase = currentPhase;\r\n        raised = totalRaised;\r\n        tokensSold = totalTokensSold;\r\n        privateTokensSold = privateSaleTokensSold;\r\n        publicTokensSold = publicSaleTokensSold;\r\n    }\r\n}\r\n"
    },
    "contracts/EquorumLiquidityManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"./interfaces/IEquorumCore.sol\";\r\n\r\n/**\r\n * @title EquorumLiquidityManager\r\n * @author Equorum Protocol\r\n * @notice Manages EQM token liquidity deployment to DEX pools\r\n * @dev Simplified version of original LiquidityBuffer without oracle dependencies\r\n * \r\n * FEATURES:\r\n * - Manages 500K EQM tokens for liquidity\r\n * - Controlled deployment to approved pools\r\n * - Withdrawal tracking and management\r\n * - Pool approval system\r\n * - Pausable for emergency control\r\n * - Compatible with IEquorumCore interface\r\n * \r\n * SECURITY:\r\n * - Only approved pools can receive liquidity\r\n * - Owner-controlled deployment\r\n * - Withdrawal tracking prevents over-deployment\r\n * - ReentrancyGuard on all state-changing functions\r\n * - Emergency pause mechanism\r\n * \r\n * ARBITRUM L2 OPTIMIZATIONS:\r\n * - Minimal storage operations\r\n * - Gas-efficient pool tracking\r\n * - Event-driven state updates\r\n * - Optimized for low L2 gas costs\r\n * \r\n * USAGE:\r\n * 1. Owner approves DEX pool addresses (Uniswap, Camelot, etc)\r\n * 2. Owner deploys liquidity to approved pools\r\n * 3. Liquidity can be withdrawn if needed\r\n * 4. All operations tracked on-chain\r\n */\r\ncontract EquorumLiquidityManager is IEquorumCore, Ownable, Pausable, ReentrancyGuard {\r\n    \r\n    // ========== CONSTANTS ==========\r\n    \r\n    /// @notice Total liquidity allocation (500K EQM)\r\n    uint256 public constant LIQUIDITY_ALLOCATION = 500_000 * 1e18;\r\n    \r\n    // ========== STATE VARIABLES ==========\r\n    \r\n    /// @notice EQM token contract\r\n    IERC20 public immutable equorumToken;\r\n    \r\n    /// @notice Total tokens deployed to pools\r\n    uint256 public totalDeployed;\r\n    \r\n    /// @notice Amount deployed to each pool\r\n    mapping(address => uint256) public deployedToPools;\r\n    \r\n    /// @notice Approved pool addresses\r\n    mapping(address => bool) public approvedPools;\r\n    \r\n    /// @notice Deployment history for tracking\r\n    mapping(address => uint256) public deploymentCount;\r\n    \r\n    // ========== EVENTS ==========\r\n    \r\n    /// @notice Emitted when liquidity is deployed to a pool\r\n    event LiquidityDeployed(address indexed pool, uint256 amount, uint256 timestamp);\r\n    \r\n    /// @notice Emitted when liquidity is withdrawn from tracking\r\n    event LiquidityWithdrawn(address indexed pool, uint256 amount, uint256 timestamp);\r\n    \r\n    /// @notice Emitted when pool approval status changes\r\n    event PoolApproved(address indexed pool, bool status);\r\n    \r\n    /// @notice Emitted when emergency withdrawal occurs\r\n    event EmergencyWithdrawal(address indexed to, uint256 amount);\r\n    \r\n    // ========== CONSTRUCTOR ==========\r\n    \r\n    /**\r\n     * @notice Initializes the liquidity manager\r\n     * @dev Contract starts PAUSED - owner must unpause to activate\r\n     * @param _equorumToken Address of EQM token contract\r\n     */\r\n    constructor(address _equorumToken) {\r\n        require(_equorumToken != address(0), \"Invalid token address\");\r\n        equorumToken = IERC20(_equorumToken);\r\n        \r\n        // Start paused - owner activates when ready\r\n        _pause();\r\n    }\r\n    \r\n    // ========== CORE FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Deploys liquidity to an approved pool\r\n     * @dev Pool must be pre-approved by owner\r\n     * @param pool Address of DEX pool (Uniswap, Camelot, etc)\r\n     * @param amount Amount of EQM tokens to deploy\r\n     * \r\n     * ARBITRUM OPTIMIZATION:\r\n     * - Single transfer operation\r\n     * - Minimal state updates\r\n     * - Gas-efficient tracking\r\n     */\r\n    function deployLiquidity(address pool, uint256 amount) \r\n        external \r\n        onlyOwner \r\n        nonReentrant \r\n        whenNotPaused \r\n    {\r\n        require(approvedPools[pool], \"Pool not approved\");\r\n        require(amount > 0, \"Amount must be greater than zero\");\r\n        require(totalDeployed + amount <= LIQUIDITY_ALLOCATION, \"Exceeds allocation\");\r\n        \r\n        uint256 balance = equorumToken.balanceOf(address(this));\r\n        require(balance >= amount, \"Insufficient contract balance\");\r\n        \r\n        // Update state\r\n        totalDeployed += amount;\r\n        deployedToPools[pool] += amount;\r\n        deploymentCount[pool]++;\r\n        \r\n        // Transfer tokens to pool\r\n        require(equorumToken.transfer(pool, amount), \"Transfer failed\");\r\n        \r\n        emit LiquidityDeployed(pool, amount, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Updates withdrawal tracking for a pool\r\n     * @dev Does not actually withdraw tokens - only updates accounting\r\n     * @param pool Address of pool\r\n     * @param amount Amount to mark as withdrawn\r\n     * \r\n     * NOTE: This is for accounting purposes when liquidity is removed\r\n     * from pools manually. The actual LP token withdrawal happens\r\n     * outside this contract.\r\n     */\r\n    function withdrawLiquidity(address pool, uint256 amount) \r\n        external \r\n        onlyOwner \r\n        nonReentrant \r\n    {\r\n        require(deployedToPools[pool] >= amount, \"Insufficient deployed amount\");\r\n        \r\n        // Update tracking\r\n        deployedToPools[pool] -= amount;\r\n        totalDeployed -= amount;\r\n        \r\n        emit LiquidityWithdrawn(pool, amount, block.timestamp);\r\n    }\r\n    \r\n    // ========== ADMIN FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Approves or revokes pool for liquidity deployment\r\n     * @dev Only approved pools can receive liquidity\r\n     * @param pool Address of DEX pool\r\n     * @param status True to approve, false to revoke\r\n     */\r\n    function approvePool(address pool, bool status) external onlyOwner {\r\n        require(pool != address(0), \"Invalid pool address\");\r\n        approvedPools[pool] = status;\r\n        emit PoolApproved(pool, status);\r\n    }\r\n    \r\n    /**\r\n     * @notice Batch approve multiple pools\r\n     * @dev Gas-optimized for multiple approvals\r\n     * @param pools Array of pool addresses\r\n     * @param statuses Array of approval statuses\r\n     */\r\n    function batchApprovePool(address[] calldata pools, bool[] calldata statuses) \r\n        external \r\n        onlyOwner \r\n    {\r\n        require(pools.length == statuses.length, \"Length mismatch\");\r\n        \r\n        uint256 length = pools.length;\r\n        for (uint256 i = 0; i < length;) {\r\n            require(pools[i] != address(0), \"Invalid pool address\");\r\n            approvedPools[pools[i]] = statuses[i];\r\n            emit PoolApproved(pools[i], statuses[i]);\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Activates liquidity management (unpauses)\r\n     * @dev Owner calls when ready to deploy liquidity\r\n     */\r\n    function activate() external onlyOwner {\r\n        _unpause();\r\n    }\r\n    \r\n    /**\r\n     * @notice Deactivates liquidity management (pauses)\r\n     */\r\n    function deactivate() external onlyOwner {\r\n        _pause();\r\n    }\r\n    \r\n    /**\r\n     * @notice Emergency withdrawal of tokens\r\n     * @dev Use only in emergency situations\r\n     * @param to Destination address\r\n     * @param amount Amount to withdraw\r\n     */\r\n    function emergencyWithdraw(address to, uint256 amount) external onlyOwner {\r\n        require(to != address(0), \"Invalid address\");\r\n        uint256 balance = equorumToken.balanceOf(address(this));\r\n        require(amount <= balance, \"Insufficient balance\");\r\n        \r\n        require(equorumToken.transfer(to, amount), \"Transfer failed\");\r\n        emit EmergencyWithdrawal(to, amount);\r\n    }\r\n    \r\n    // ========== VIEW FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Returns available liquidity in contract\r\n     * @return Available EQM token balance\r\n     */\r\n    function getAvailableLiquidity() external view returns (uint256) {\r\n        return equorumToken.balanceOf(address(this));\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns deployment statistics for a pool\r\n     * @param pool Pool address\r\n     * @return deployed Amount deployed to pool\r\n     * @return count Number of deployments\r\n     * @return approved Whether pool is approved\r\n     */\r\n    function getPoolStats(address pool) external view returns (\r\n        uint256 deployed,\r\n        uint256 count,\r\n        bool approved\r\n    ) {\r\n        return (\r\n            deployedToPools[pool],\r\n            deploymentCount[pool],\r\n            approvedPools[pool]\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns overall liquidity statistics\r\n     * @return total Total allocation\r\n     * @return deployed Total deployed\r\n     * @return available Available in contract\r\n     * @return isPaused Whether contract is paused\r\n     */\r\n    function getLiquidityStats() external view returns (\r\n        uint256 total,\r\n        uint256 deployed,\r\n        uint256 available,\r\n        bool isPaused\r\n    ) {\r\n        return (\r\n            LIQUIDITY_ALLOCATION,\r\n            totalDeployed,\r\n            equorumToken.balanceOf(address(this)),\r\n            paused()\r\n        );\r\n    }\r\n    \r\n    // ========== IEQUORUMCORE IMPLEMENTATION ==========\r\n    \r\n    /**\r\n     * @notice Processes system action\r\n     * @dev Action types: 1=Regular (unused), 2=Critical (pause if low), 3=Emergency (pause)\r\n     * @param actionType Type of action\r\n     * @param data Additional data (unused)\r\n     */\r\n    function processSystemAction(uint8 actionType, bytes calldata data) external override onlyOwner {\r\n        if (actionType == 2) {\r\n            // Critical: Pause if balance critically low\r\n            uint256 balance = equorumToken.balanceOf(address(this));\r\n            if (balance < LIQUIDITY_ALLOCATION / 10) {\r\n                _pause();\r\n            }\r\n        } else if (actionType == 3) {\r\n            // Emergency: Immediate pause\r\n            _pause();\r\n        }\r\n        \r\n        emit SystemAction(address(this), \"Liquidity action\", actionType, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Emergency stop\r\n     * @param reason Reason for stop\r\n     */\r\n    function emergencyStop(string calldata reason) external override onlyOwner {\r\n        _pause();\r\n        emit EmergencyAction(address(this), reason, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Updates parameters (not supported - values are constants)\r\n     * @dev Kept for IEquorumCore compatibility\r\n     */\r\n    function updateParameters(string[] calldata, uint256[] calldata) external override onlyOwner {\r\n        // Liquidity manager uses constants - no parameter updates\r\n        emit SystemAction(address(this), \"Parameter update not supported\", 0, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Validates contract state\r\n     * @return checksum Hash of current state\r\n     */\r\n    function validateState() external view override returns (bytes32) {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                address(equorumToken),\r\n                totalDeployed,\r\n                paused()\r\n            )\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @notice Verifies integrations\r\n     * @param contracts Array with [equorumToken]\r\n     * @return valid True if integration valid\r\n     */\r\n    function verifyIntegrations(address[] calldata contracts) external view override returns (bool) {\r\n        if (contracts.length != 1) return false;\r\n        return contracts[0] == address(equorumToken);\r\n    }\r\n}\r\n\r\n"
    },
    "contracts/EquorumReserveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"./interfaces/IEquorumCore.sol\";\r\n\r\n/**\r\n * @title EquorumReserveManager\r\n * @author Equorum Protocol\r\n * @notice Manages Foundation and Corporate reserve token allocations\r\n * @dev New contract for V2 - manages two separate reserve pools\r\n * \r\n * FEATURES:\r\n * - Manages 244K EQM tokens (122K Foundation + 122K Corporate)\r\n * - Separate tracking for each reserve type\r\n * - Purpose-documented releases (on-chain transparency)\r\n * - Recipient approval system\r\n * - Configurable foundation and corporate addresses\r\n * - Pausable for emergency control\r\n * - Compatible with IEquorumCore interface\r\n * \r\n * SECURITY:\r\n * - Only approved recipients can receive tokens\r\n * - Owner-controlled releases\r\n * - Purpose documentation for transparency\r\n * - Separate allocation limits prevent cross-contamination\r\n * - Balance sanity checks prevent underfunded releases\r\n * - ReentrancyGuard on all state-changing functions\r\n * - Emergency pause mechanism\r\n * \r\n * POOL ISOLATION:\r\n * - Each release verifies contract has sufficient balance\r\n * - Sanity check ensures total allocation is properly funded\r\n * - Prevents \"cross-contamination\" between foundation and corporate pools\r\n * \r\n * ARBITRUM L2 OPTIMIZATIONS:\r\n * - Minimal storage operations\r\n * - Gas-efficient release tracking\r\n * - Event-driven transparency\r\n * - Custom errors for gas savings\r\n * \r\n * USAGE:\r\n * Foundation Reserve (122K):\r\n * - Development funding\r\n * - Security audits\r\n * - Protocol improvements\r\n * - Developer grants\r\n * \r\n * Corporate Reserve (122K):\r\n * - Exchange listings\r\n * - Strategic partnerships\r\n * - Marketing initiatives\r\n * - Business development\r\n * \r\n * GOVERNANCE TRANSITION:\r\n * Phase 1: Owner = deployer/multisig (initial setup)\r\n * Phase 2: transferOwnership(TimeLock) when governance is stable\r\n * This ensures decentralized control of reserve releases\r\n */\r\ncontract EquorumReserveManager is IEquorumCore, Ownable, Pausable, ReentrancyGuard {\r\n    \r\n    // ========== CUSTOM ERRORS ==========\r\n    error InvalidAddress();\r\n    error InvalidAmount();\r\n    error ExceedsFoundationAllocation();\r\n    error ExceedsCorporateAllocation();\r\n    error RecipientNotApproved();\r\n    error PurposeRequired();\r\n    error TransferFailed();\r\n    error LengthMismatch();\r\n    error InsufficientBalance();\r\n    error ReserveUnderfunded();\r\n    error AddressesNotConfigured();\r\n    \r\n    // ========== CONSTANTS ==========\r\n    \r\n    /// @notice Foundation reserve allocation (122K EQM)\r\n    uint256 public constant FOUNDATION_ALLOCATION = 122_000 * 1e18;\r\n    \r\n    /// @notice Corporate reserve allocation (122K EQM)\r\n    uint256 public constant CORPORATE_ALLOCATION = 122_000 * 1e18;\r\n    \r\n    /// @notice Total reserve allocation (244K EQM)\r\n    uint256 public constant TOTAL_ALLOCATION = 244_000 * 1e18;\r\n    \r\n    // ========== STATE VARIABLES ==========\r\n    \r\n    /// @notice EQM token contract\r\n    IERC20 public immutable equorumToken;\r\n    \r\n    /// @notice Total foundation tokens released\r\n    uint256 public foundationReleased;\r\n    \r\n    /// @notice Total corporate tokens released\r\n    uint256 public corporateReleased;\r\n    \r\n    /// @notice Official foundation address\r\n    address public foundationAddress;\r\n    \r\n    /// @notice Official corporate address\r\n    address public corporateAddress;\r\n    \r\n    /// @notice Approved recipient addresses\r\n    mapping(address => bool) public approvedRecipients;\r\n    \r\n    /// @notice Release history count per address\r\n    mapping(address => uint256) public releaseCount;\r\n    \r\n    // ========== EVENTS ==========\r\n    \r\n    /// @notice Emitted when foundation tokens are released\r\n    event FoundationRelease(\r\n        address indexed to, \r\n        uint256 amount, \r\n        string purpose, \r\n        uint256 timestamp\r\n    );\r\n    \r\n    /// @notice Emitted when corporate tokens are released\r\n    event CorporateRelease(\r\n        address indexed to, \r\n        uint256 amount, \r\n        string purpose, \r\n        uint256 timestamp\r\n    );\r\n    \r\n    /// @notice Emitted when foundation or corporate address is updated\r\n    event AddressUpdated(\r\n        string indexed reserveType, \r\n        address indexed newAddress\r\n    );\r\n    \r\n    /// @notice Emitted when recipient approval status changes\r\n    event RecipientApproved(\r\n        address indexed recipient, \r\n        bool status\r\n    );\r\n    \r\n    /// @notice Emitted when emergency withdrawal occurs\r\n    event EmergencyWithdrawal(\r\n        address indexed to, \r\n        uint256 amount\r\n    );\r\n    \r\n    // ========== CONSTRUCTOR ==========\r\n    \r\n    /**\r\n     * @notice Initializes the reserve manager\r\n     * @dev Contract starts PAUSED - owner must unpause to activate\r\n     * @param _equorumToken Address of EQM token contract\r\n     */\r\n    constructor(address _equorumToken) {\r\n        if (_equorumToken == address(0)) revert InvalidAddress();\r\n        equorumToken = IERC20(_equorumToken);\r\n        \r\n        // Start paused - owner activates when ready\r\n        _pause();\r\n    }\r\n    \r\n    // ========== CORE FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Releases foundation reserve tokens\r\n     * @dev Recipient must be approved or be the foundation address\r\n     * @param to Recipient address\r\n     * @param amount Amount of tokens to release\r\n     * @param purpose Description of release purpose (on-chain documentation)\r\n     * \r\n     * EXAMPLES:\r\n     * - \"Security audit by OpenZeppelin\"\r\n     * - \"Developer grant for DeFi integration\"\r\n     * - \"Protocol upgrade development\"\r\n     * \r\n     * ARBITRUM OPTIMIZATION:\r\n     * - Single transfer operation\r\n     * - Minimal state updates\r\n     * - Gas-efficient tracking\r\n     */\r\n    function releaseFoundation(\r\n        address to, \r\n        uint256 amount, \r\n        string calldata purpose\r\n    ) \r\n        external \r\n        onlyOwner \r\n        nonReentrant \r\n        whenNotPaused \r\n    {\r\n        if (to == address(0)) revert InvalidAddress();\r\n        if (amount == 0) revert InvalidAmount();\r\n        if (foundationReleased + amount > FOUNDATION_ALLOCATION) revert ExceedsFoundationAllocation();\r\n        if (!approvedRecipients[to] && to != foundationAddress) revert RecipientNotApproved();\r\n        if (bytes(purpose).length == 0) revert PurposeRequired();\r\n        \r\n        // CRITICAL: Verify contract has sufficient balance (prevents pool contamination)\r\n        uint256 balance = equorumToken.balanceOf(address(this));\r\n        if (balance < amount) revert InsufficientBalance();\r\n        \r\n        // Sanity check: ensure reserve is properly funded\r\n        uint256 totalRemaining = TOTAL_ALLOCATION - foundationReleased - corporateReleased;\r\n        if (balance < totalRemaining) revert ReserveUnderfunded();\r\n        \r\n        // Update state\r\n        foundationReleased += amount;\r\n        releaseCount[to]++;\r\n        \r\n        // Transfer tokens\r\n        if (!equorumToken.transfer(to, amount)) revert TransferFailed();\r\n        \r\n        emit FoundationRelease(to, amount, purpose, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Releases corporate reserve tokens\r\n     * @dev Recipient must be approved or be the corporate address\r\n     * @param to Recipient address\r\n     * @param amount Amount of tokens to release\r\n     * @param purpose Description of release purpose (on-chain documentation)\r\n     * \r\n     * EXAMPLES:\r\n     * - \"Gate.io listing fee\"\r\n     * - \"Marketing campaign Q1 2025\"\r\n     * - \"Partnership with Protocol X\"\r\n     * \r\n     * ARBITRUM OPTIMIZATION:\r\n     * - Single transfer operation\r\n     * - Minimal state updates\r\n     * - Gas-efficient tracking\r\n     */\r\n    function releaseCorporate(\r\n        address to, \r\n        uint256 amount, \r\n        string calldata purpose\r\n    ) \r\n        external \r\n        onlyOwner \r\n        nonReentrant \r\n        whenNotPaused \r\n    {\r\n        if (to == address(0)) revert InvalidAddress();\r\n        if (amount == 0) revert InvalidAmount();\r\n        if (corporateReleased + amount > CORPORATE_ALLOCATION) revert ExceedsCorporateAllocation();\r\n        if (!approvedRecipients[to] && to != corporateAddress) revert RecipientNotApproved();\r\n        if (bytes(purpose).length == 0) revert PurposeRequired();\r\n        \r\n        // CRITICAL: Verify contract has sufficient balance (prevents pool contamination)\r\n        uint256 balance = equorumToken.balanceOf(address(this));\r\n        if (balance < amount) revert InsufficientBalance();\r\n        \r\n        // Sanity check: ensure reserve is properly funded\r\n        uint256 totalRemaining = TOTAL_ALLOCATION - foundationReleased - corporateReleased;\r\n        if (balance < totalRemaining) revert ReserveUnderfunded();\r\n        \r\n        // Update state\r\n        corporateReleased += amount;\r\n        releaseCount[to]++;\r\n        \r\n        // Transfer tokens\r\n        if (!equorumToken.transfer(to, amount)) revert TransferFailed();\r\n        \r\n        emit CorporateRelease(to, amount, purpose, block.timestamp);\r\n    }\r\n    \r\n    // ========== ADMIN FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Sets the official foundation address\r\n     * @dev Foundation address can receive without approval\r\n     * @param _address New foundation address\r\n     */\r\n    function setFoundationAddress(address _address) external onlyOwner {\r\n        if (_address == address(0)) revert InvalidAddress();\r\n        foundationAddress = _address;\r\n        emit AddressUpdated(\"foundation\", _address);\r\n    }\r\n    \r\n    /**\r\n     * @notice Sets the official corporate address\r\n     * @dev Corporate address can receive without approval\r\n     * @param _address New corporate address\r\n     */\r\n    function setCorporateAddress(address _address) external onlyOwner {\r\n        if (_address == address(0)) revert InvalidAddress();\r\n        corporateAddress = _address;\r\n        emit AddressUpdated(\"corporate\", _address);\r\n    }\r\n    \r\n    /**\r\n     * @notice Approves or revokes recipient for token releases\r\n     * @param recipient Address to approve/revoke\r\n     * @param status True to approve, false to revoke\r\n     */\r\n    function approveRecipient(address recipient, bool status) external onlyOwner {\r\n        if (recipient == address(0)) revert InvalidAddress();\r\n        approvedRecipients[recipient] = status;\r\n        emit RecipientApproved(recipient, status);\r\n    }\r\n    \r\n    /**\r\n     * @notice Batch approve multiple recipients\r\n     * @dev Gas-optimized for multiple approvals\r\n     * @param recipients Array of addresses to approve\r\n     * @param statuses Array of approval statuses\r\n     */\r\n    function batchApproveRecipients(\r\n        address[] calldata recipients, \r\n        bool[] calldata statuses\r\n    ) \r\n        external \r\n        onlyOwner \r\n    {\r\n        if (recipients.length != statuses.length) revert LengthMismatch();\r\n        \r\n        uint256 length = recipients.length;\r\n        for (uint256 i = 0; i < length;) {\r\n            if (recipients[i] == address(0)) revert InvalidAddress();\r\n            approvedRecipients[recipients[i]] = statuses[i];\r\n            emit RecipientApproved(recipients[i], statuses[i]);\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Activates reserve management (unpauses)\r\n     * @dev Requires at least one address (foundation or corporate) to be configured\r\n     * @dev This prevents activation with no way to release tokens\r\n     */\r\n    function activate() external onlyOwner {\r\n        // CRITICAL: Require at least one address configured to prevent UX issues\r\n        if (foundationAddress == address(0) && corporateAddress == address(0)) {\r\n            revert AddressesNotConfigured();\r\n        }\r\n        _unpause();\r\n    }\r\n    \r\n    /**\r\n     * @notice Deactivates reserve management (pauses)\r\n     */\r\n    function deactivate() external onlyOwner {\r\n        _pause();\r\n    }\r\n    \r\n    /**\r\n     * @notice Emergency withdrawal of tokens\r\n     * @dev Use only in emergency situations\r\n     * @param to Destination address\r\n     * @param amount Amount to withdraw\r\n     */\r\n    function emergencyWithdraw(address to, uint256 amount) external onlyOwner {\r\n        if (to == address(0)) revert InvalidAddress();\r\n        uint256 balance = equorumToken.balanceOf(address(this));\r\n        if (amount > balance) revert InsufficientBalance();\r\n        \r\n        if (!equorumToken.transfer(to, amount)) revert TransferFailed();\r\n        emit EmergencyWithdrawal(to, amount);\r\n    }\r\n    \r\n    // ========== VIEW FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Returns reserve statistics\r\n     * @return foundationRemaining Remaining foundation allocation\r\n     * @return corporateRemaining Remaining corporate allocation\r\n     * @return totalRemaining Total remaining allocation\r\n     * @return contractBalance Current contract balance\r\n     */\r\n    function getReserveStats() external view returns (\r\n        uint256 foundationRemaining,\r\n        uint256 corporateRemaining,\r\n        uint256 totalRemaining,\r\n        uint256 contractBalance\r\n    ) {\r\n        return (\r\n            FOUNDATION_ALLOCATION - foundationReleased,\r\n            CORPORATE_ALLOCATION - corporateReleased,\r\n            TOTAL_ALLOCATION - foundationReleased - corporateReleased,\r\n            equorumToken.balanceOf(address(this))\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns recipient information\r\n     * @param recipient Address to query\r\n     * @return approved Whether recipient is approved\r\n     * @return releases Number of releases to recipient\r\n     */\r\n    function getRecipientInfo(address recipient) external view returns (\r\n        bool approved,\r\n        uint256 releases\r\n    ) {\r\n        return (\r\n            approvedRecipients[recipient],\r\n            releaseCount[recipient]\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns detailed reserve information\r\n     * @return foundationAddr Foundation address\r\n     * @return corporateAddr Corporate address\r\n     * @return foundationRel Foundation released amount\r\n     * @return corporateRel Corporate released amount\r\n     * @return isPaused Whether contract is paused\r\n     */\r\n    function getReserveInfo() external view returns (\r\n        address foundationAddr,\r\n        address corporateAddr,\r\n        uint256 foundationRel,\r\n        uint256 corporateRel,\r\n        bool isPaused\r\n    ) {\r\n        return (\r\n            foundationAddress,\r\n            corporateAddress,\r\n            foundationReleased,\r\n            corporateReleased,\r\n            paused()\r\n        );\r\n    }\r\n    \r\n    // ========== IEQUORUMCORE IMPLEMENTATION ==========\r\n    \r\n    /**\r\n     * @notice Processes system action\r\n     * @dev Action types: 1=Regular (unused), 2=Critical (unused), 3=Emergency (pause)\r\n     * @param actionType Type of action\r\n     * @param data Additional data (unused)\r\n     */\r\n    function processSystemAction(uint8 actionType, bytes calldata data) external override onlyOwner {\r\n        if (actionType == 3) {\r\n            // Emergency: Immediate pause\r\n            _pause();\r\n        }\r\n        \r\n        emit SystemAction(address(this), \"Reserve action\", actionType, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Emergency stop\r\n     * @param reason Reason for stop\r\n     */\r\n    function emergencyStop(string calldata reason) external override onlyOwner {\r\n        _pause();\r\n        emit EmergencyAction(address(this), reason, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Updates parameters (not supported - values are constants)\r\n     * @dev Kept for IEquorumCore compatibility\r\n     */\r\n    function updateParameters(string[] calldata, uint256[] calldata) external override onlyOwner {\r\n        // Reserve manager uses constants - no parameter updates\r\n        emit SystemAction(address(this), \"Parameter update not supported\", 0, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Validates contract state\r\n     * @return checksum Hash of current state\r\n     */\r\n    function validateState() external view override returns (bytes32) {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                address(equorumToken),\r\n                foundationReleased,\r\n                corporateReleased,\r\n                paused()\r\n            )\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @notice Verifies integrations\r\n     * @param contracts Array with [equorumToken]\r\n     * @return valid True if integration valid\r\n     */\r\n    function verifyIntegrations(address[] calldata contracts) external view override returns (bool) {\r\n        if (contracts.length != 1) return false;\r\n        return contracts[0] == address(equorumToken);\r\n    }\r\n}\r\n\r\n"
    },
    "contracts/EquorumStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\n\r\n/**\r\n * @title EquorumStaking\r\n * @notice Staking contract with DYNAMIC APY rewards (like central bank)\r\n * @dev Optimized for Arbitrum L2 with efficient storage and gas patterns\r\n * \r\n * FEATURES:\r\n * - Dynamic APY: 1.0% - 3.5% (auto-regulated)\r\n * - APY adjusts every 30 days based on utilization\r\n * - Low utilization (<25%)  Higher APY (3.5%) to incentivize\r\n * - High utilization (>75%)  Lower APY (1.0%) to control inflation\r\n * - Medium utilization (25-75%)  Base APY (2.5%)\r\n * - Cooldown: 7 days for unstake\r\n * - Rewards calculated per second\r\n * - Emergency withdrawal functionality\r\n * - Graceful reward payout (pays available if insufficient)\r\n * \r\n * INNOVATION:\r\n * - Works like FED/ECB regulating interest rates\r\n * - Sustainable tokenomics (no 1000% APY scams)\r\n * - Predictable adjustments (30-day periods)\r\n * - Transparent and automatic\r\n * \r\n * ARBITRUM L2 OPTIMIZATIONS:\r\n * - Compact struct packing\r\n * - Minimal storage writes\r\n * - Efficient reward calculations\r\n * - Gas-optimized operations\r\n */\r\ncontract EquorumStaking is Ownable, ReentrancyGuard, Pausable {\r\n    \r\n    // ========== CUSTOM ERRORS ==========\r\n    error InvalidAddress();\r\n    error AmountMustBeGreaterThanZero();\r\n    error GenesisCannotStake();\r\n    error StakingCapExceeded();\r\n    error NoStakeFound();\r\n    error CooldownAlreadyStarted();\r\n    error CooldownNotStarted();\r\n    error CooldownNotFinished();\r\n    error AmountExceedsStake();\r\n    error TransferFailed();\r\n    error AdjustmentPeriodNotElapsed();\r\n    \r\n    // ========== CONSTANTS ==========\r\n    /// @notice Base APY rate (2.5% = 250 basis points)\r\n    uint256 public constant APY_BASE = 250; // 2.5% (base 10000)\r\n    /// @notice Minimum APY rate (1.0% = 100 basis points)\r\n    uint256 public constant APY_MIN = 100; // 1.0%\r\n    /// @notice Maximum APY rate (3.5% = 350 basis points)\r\n    uint256 public constant APY_MAX = 350; // 3.5%\r\n    /// @notice Denominator for APY calculations\r\n    uint256 public constant APY_DENOMINATOR = 10000;\r\n    /// @notice Cooldown period before unstaking (7 days)\r\n    uint256 public constant COOLDOWN_PERIOD = 7 days;\r\n    /// @notice Seconds in a year for reward calculations\r\n    uint256 public constant SECONDS_PER_YEAR = 365 days;\r\n    /// @notice APY adjustment period (30 days)\r\n    uint256 public constant ADJUSTMENT_PERIOD = 30 days;\r\n    /// @notice Maximum staking cap (38M tokens = 79.17% of supply)\r\n    uint256 public constant STAKING_CAP = 38_000_000 * 1e18;\r\n    /// @notice Low utilization threshold (25%)\r\n    uint256 public constant LOW_UTIL_THRESHOLD = 2500; // 25% (base 10000)\r\n    /// @notice High utilization threshold (75%)\r\n    uint256 public constant HIGH_UTIL_THRESHOLD = 7500; // 75% (base 10000)\r\n    \r\n    // ========== STATE VARIABLES ==========\r\n    /// @notice Equorum token contract (immutable for gas savings)\r\n    IERC20 public immutable equorumToken;\r\n    \r\n    /// @notice Genesis vesting contract (excluded from staking)\r\n    address public immutable genesisVesting;\r\n    \r\n    /// @notice Total amount of tokens currently staked\r\n    uint256 public totalStaked;\r\n    /// @notice Total rewards paid out to all users\r\n    uint256 public totalRewardsPaid;\r\n    /// @notice Current APY rate (dynamic)\r\n    uint256 public currentAPY;\r\n    /// @notice Last APY adjustment timestamp\r\n    uint256 public lastAdjustment;\r\n    \r\n    /// @notice Stake information for each user\r\n    /// @dev Optimized struct layout for Arbitrum L2\r\n    struct Stake {\r\n        uint256 amount;           // Amount staked\r\n        uint256 startTime;        // Timestamp when stake started\r\n        uint256 lastClaimTime;    // Last time rewards were claimed\r\n        uint256 cooldownStart;    // Cooldown start timestamp (0 if not started)\r\n    }\r\n    \r\n    mapping(address => Stake) public stakes;\r\n    \r\n    // ========== EVENTS ==========\r\n    event Staked(address indexed user, uint256 amount);\r\n    event Unstaked(address indexed user, uint256 amount);\r\n    event RewardsClaimed(address indexed user, uint256 amount);\r\n    event CooldownStarted(address indexed user, uint256 timestamp);\r\n    event EmergencyWithdraw(address indexed user, uint256 amount);\r\n    event APYAdjusted(uint256 newAPY, uint256 utilization, uint256 timestamp);\r\n    \r\n    // ========== CONSTRUCTOR ==========\r\n    /**\r\n     * @notice Initializes the staking contract\r\n     * @param _equorumToken Address of the Equorum token\r\n     * @param _genesisVesting Address of Genesis vesting contract (excluded from staking)\r\n     * @dev Sets addresses as immutable for gas efficiency\r\n     * @dev Genesis cannot stake to prevent voting power manipulation\r\n     */\r\n    constructor(address _equorumToken, address _genesisVesting) {\r\n        if (_equorumToken == address(0)) revert InvalidAddress();\r\n        if (_genesisVesting == address(0)) revert InvalidAddress();\r\n        equorumToken = IERC20(_equorumToken);\r\n        genesisVesting = _genesisVesting;\r\n        currentAPY = APY_BASE; // Start with 2.5%\r\n        lastAdjustment = block.timestamp;\r\n    }\r\n    \r\n    // ========== STAKING FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Stakes tokens to earn rewards\r\n     * @param amount Amount of tokens to stake\r\n     * @dev Claims pending rewards before updating stake\r\n     * @dev Resets cooldown if user was in cooldown period\r\n     * @dev Genesis vesting contract cannot stake\r\n     * @dev Enforces STAKING_CAP to prevent exceeding pool capacity\r\n     */\r\n    function stake(uint256 amount) external nonReentrant whenNotPaused {\r\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\r\n        if (msg.sender == genesisVesting) revert GenesisCannotStake();\r\n        if (totalStaked + amount > STAKING_CAP) revert StakingCapExceeded();\r\n        \r\n        Stake storage userStake = stakes[msg.sender];\r\n        \r\n        // Calculate pending rewards BEFORE any state changes (critical fix)\r\n        uint256 pendingRewards = 0;\r\n        if (userStake.amount > 0) {\r\n            pendingRewards = calculateRewards(msg.sender);\r\n            // Graceful payout: pay what's available if insufficient\r\n            if (pendingRewards > 0) {\r\n                uint256 availableRewards = equorumToken.balanceOf(address(this)) - totalStaked;\r\n                if (pendingRewards > availableRewards) {\r\n                    pendingRewards = availableRewards; // Pay what we have\r\n                }\r\n            }\r\n        }\r\n        \r\n        // EFFECTS: Update all state variables BEFORE interactions\r\n        if (userStake.amount == 0) {\r\n            userStake.startTime = block.timestamp;\r\n        }\r\n        userStake.amount += amount;\r\n        userStake.lastClaimTime = block.timestamp;\r\n        userStake.cooldownStart = 0;\r\n        totalStaked += amount;\r\n        \r\n        // Track rewards paid\r\n        if (pendingRewards > 0) {\r\n            totalRewardsPaid += pendingRewards;\r\n        }\r\n        \r\n        // INTERACTIONS: External calls LAST\r\n        if (!equorumToken.transferFrom(msg.sender, address(this), amount)) revert TransferFailed();\r\n        \r\n        // Transfer pending rewards (using saved value, not recalculated)\r\n        if (pendingRewards > 0) {\r\n            if (!equorumToken.transfer(msg.sender, pendingRewards)) revert TransferFailed();\r\n            emit RewardsClaimed(msg.sender, pendingRewards);\r\n        }\r\n        \r\n        emit Staked(msg.sender, amount);\r\n    }\r\n    \r\n    /**\r\n     * @notice Starts the cooldown period before unstaking\r\n     * @dev Must wait COOLDOWN_PERIOD (7 days) before unstaking\r\n     * @dev Claims pending rewards before starting cooldown\r\n     */\r\n    function startCooldown() external nonReentrant {\r\n        Stake storage userStake = stakes[msg.sender];\r\n        \r\n        if (userStake.amount == 0) revert NoStakeFound();\r\n        if (userStake.cooldownStart != 0) revert CooldownAlreadyStarted();\r\n        \r\n        // Calculate rewards BEFORE state changes\r\n        uint256 pendingRewards = calculateRewards(msg.sender);\r\n        \r\n        // Graceful payout: pay what's available if insufficient\r\n        if (pendingRewards > 0) {\r\n            uint256 availableRewards = equorumToken.balanceOf(address(this)) - totalStaked;\r\n            if (pendingRewards > availableRewards) {\r\n                pendingRewards = availableRewards;\r\n            }\r\n        }\r\n        \r\n        // EFFECTS: Update state BEFORE interactions\r\n        userStake.lastClaimTime = block.timestamp;\r\n        userStake.cooldownStart = block.timestamp;\r\n        \r\n        if (pendingRewards > 0) {\r\n            totalRewardsPaid += pendingRewards;\r\n        }\r\n        \r\n        // INTERACTIONS: External call LAST\r\n        if (pendingRewards > 0) {\r\n            if (!equorumToken.transfer(msg.sender, pendingRewards)) revert TransferFailed();\r\n            emit RewardsClaimed(msg.sender, pendingRewards);\r\n        }\r\n        \r\n        emit CooldownStarted(msg.sender, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Unstakes tokens after cooldown period\r\n     * @param amount Amount to unstake (0 = withdraw all)\r\n     * @dev Requires cooldown to be started and completed\r\n     * @dev Claims final rewards before unstaking\r\n     */\r\n    function unstake(uint256 amount) external nonReentrant {\r\n        Stake storage userStake = stakes[msg.sender];\r\n        \r\n        if (userStake.amount == 0) revert NoStakeFound();\r\n        if (userStake.cooldownStart == 0) revert CooldownNotStarted();\r\n        if (block.timestamp < userStake.cooldownStart + COOLDOWN_PERIOD) revert CooldownNotFinished();\r\n        \r\n        // If amount is 0, unstake all\r\n        if (amount == 0) {\r\n            amount = userStake.amount;\r\n        }\r\n        \r\n        if (amount > userStake.amount) revert AmountExceedsStake();\r\n        \r\n        // Calculate rewards BEFORE state changes\r\n        uint256 pendingRewards = calculateRewards(msg.sender);\r\n        \r\n        // Graceful payout: pay what's available if insufficient\r\n        if (pendingRewards > 0) {\r\n            uint256 availableRewards = equorumToken.balanceOf(address(this)) - totalStaked;\r\n            if (pendingRewards > availableRewards) {\r\n                pendingRewards = availableRewards;\r\n            }\r\n        }\r\n        \r\n        // EFFECTS: Update all state BEFORE interactions\r\n        userStake.lastClaimTime = block.timestamp;\r\n        userStake.amount -= amount;\r\n        totalStaked -= amount;\r\n        \r\n        if (pendingRewards > 0) {\r\n            totalRewardsPaid += pendingRewards;\r\n        }\r\n        \r\n        // If fully unstaked, clear stake data\r\n        if (userStake.amount == 0) {\r\n            delete stakes[msg.sender];\r\n        } else {\r\n            userStake.cooldownStart = 0;\r\n        }\r\n        \r\n        // INTERACTIONS: External calls LAST\r\n        if (!equorumToken.transfer(msg.sender, amount)) revert TransferFailed();\r\n        \r\n        if (pendingRewards > 0) {\r\n            if (!equorumToken.transfer(msg.sender, pendingRewards)) revert TransferFailed();\r\n            emit RewardsClaimed(msg.sender, pendingRewards);\r\n        }\r\n        \r\n        emit Unstaked(msg.sender, amount);\r\n    }\r\n    \r\n    /**\r\n     * @notice Claims accumulated staking rewards\r\n     * @dev Can be called anytime while staking\r\n     */\r\n    function claimRewards() external nonReentrant whenNotPaused {\r\n        if (stakes[msg.sender].amount == 0) revert NoStakeFound();\r\n        _claimRewards(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * @notice Internal function to claim rewards\r\n     * @param user Address of the user claiming rewards\r\n     * @dev Graceful payout: pays available rewards if insufficient funds\r\n     */\r\n    function _claimRewards(address user) private {\r\n        Stake storage userStake = stakes[user];\r\n        \r\n        uint256 pendingRewards = calculateRewards(user);\r\n        \r\n        if (pendingRewards > 0) {\r\n            // Graceful payout: pay what's available if insufficient\r\n            uint256 availableRewards = equorumToken.balanceOf(address(this)) - totalStaked;\r\n            if (pendingRewards > availableRewards) {\r\n                pendingRewards = availableRewards;\r\n            }\r\n            \r\n            // EFFECTS: Update state BEFORE interaction\r\n            userStake.lastClaimTime = block.timestamp;\r\n            totalRewardsPaid += pendingRewards;\r\n            \r\n            // INTERACTIONS: External call LAST\r\n            if (pendingRewards > 0) {\r\n                if (!equorumToken.transfer(user, pendingRewards)) revert TransferFailed();\r\n                emit RewardsClaimed(user, pendingRewards);\r\n            }\r\n        }\r\n    }\r\n    \r\n    // ========== VIEW FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Calculates pending rewards for a user\r\n     * @param user Address of the user\r\n     * @return uint256 Amount of pending rewards\r\n     * @dev Rewards = (amount * APY * duration) / (denominator * seconds_per_year)\r\n     */\r\n    function calculateRewards(address user) public view returns (uint256) {\r\n        Stake memory userStake = stakes[user];\r\n        \r\n        if (userStake.amount == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        uint256 stakingDuration = block.timestamp - userStake.lastClaimTime;\r\n        \r\n        // Rewards = (amount * currentAPY * duration) / (denominator * seconds_per_year)\r\n        uint256 rewards = (userStake.amount * currentAPY * stakingDuration) / \r\n                         (APY_DENOMINATOR * SECONDS_PER_YEAR);\r\n        \r\n        return rewards;\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns complete stake information for a user\r\n     * @param user Address of the user\r\n     * @return amount Amount staked\r\n     * @return startTime When the stake started\r\n     * @return lastClaimTime Last reward claim time\r\n     * @return cooldownStart Cooldown start time (0 if not started)\r\n     * @return pendingRewards Pending rewards to claim\r\n     * @return canUnstake Whether user can unstake now\r\n     */\r\n    function getStakeInfo(address user) external view returns (\r\n        uint256 amount,\r\n        uint256 startTime,\r\n        uint256 lastClaimTime,\r\n        uint256 cooldownStart,\r\n        uint256 pendingRewards,\r\n        bool canUnstake\r\n    ) {\r\n        Stake memory userStake = stakes[user];\r\n        \r\n        amount = userStake.amount;\r\n        startTime = userStake.startTime;\r\n        lastClaimTime = userStake.lastClaimTime;\r\n        cooldownStart = userStake.cooldownStart;\r\n        pendingRewards = calculateRewards(user);\r\n        canUnstake = cooldownStart > 0 && \r\n                     block.timestamp >= cooldownStart + COOLDOWN_PERIOD;\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns general staking statistics\r\n     * @return _totalStaked Total amount staked by all users\r\n     * @return _totalRewardsPaid Total rewards paid out\r\n     * @return _availableRewards Available rewards in contract\r\n     * @return _apy Current APY rate\r\n     */\r\n    function getStats() external view returns (\r\n        uint256 _totalStaked,\r\n        uint256 _totalRewardsPaid,\r\n        uint256 _availableRewards,\r\n        uint256 _apy\r\n    ) {\r\n        _totalStaked = totalStaked;\r\n        _totalRewardsPaid = totalRewardsPaid;\r\n        _availableRewards = equorumToken.balanceOf(address(this)) - totalStaked;\r\n        _apy = currentAPY;\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns current utilization and next adjustment time\r\n     * @return utilization Current pool utilization (base 10000)\r\n     * @return nextAdjustment Timestamp of next APY adjustment\r\n     * @return canAdjust Whether APY can be adjusted now\r\n     */\r\n    function getUtilizationInfo() external view returns (\r\n        uint256 utilization,\r\n        uint256 nextAdjustment,\r\n        bool canAdjust\r\n    ) {\r\n        utilization = totalStaked > 0 ? (totalStaked * APY_DENOMINATOR) / STAKING_CAP : 0;\r\n        nextAdjustment = lastAdjustment + ADJUSTMENT_PERIOD;\r\n        canAdjust = block.timestamp >= nextAdjustment;\r\n    }\r\n    \r\n    // ========== ADMIN FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Adjusts APY based on current utilization (like central bank)\r\n     * @dev Can be called by anyone after 30-day period\r\n     * @dev APY increases when utilization is low (incentivize staking)\r\n     * @dev APY decreases when utilization is high (control inflation)\r\n     */\r\n    function adjustAPY() external {\r\n        if (block.timestamp < lastAdjustment + ADJUSTMENT_PERIOD) revert AdjustmentPeriodNotElapsed();\r\n        \r\n        // Calculate utilization (base 10000)\r\n        uint256 utilization = totalStaked > 0 ? (totalStaked * APY_DENOMINATOR) / STAKING_CAP : 0;\r\n        \r\n        // Adjust APY based on utilization (like central bank regulating interest rates)\r\n        if (utilization <= LOW_UTIL_THRESHOLD) {\r\n            // Low utilization (<25%): Increase APY to incentivize staking\r\n            currentAPY = APY_MAX; // 3.5%\r\n        } else if (utilization >= HIGH_UTIL_THRESHOLD) {\r\n            // High utilization (>75%): Decrease APY to control inflation\r\n            currentAPY = APY_MIN; // 1.0%\r\n        } else {\r\n            // Medium utilization (25-75%): Use base APY\r\n            currentAPY = APY_BASE; // 2.5%\r\n        }\r\n        \r\n        lastAdjustment = block.timestamp;\r\n        \r\n        emit APYAdjusted(currentAPY, utilization, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Pauses staking operations (emergency only)\r\n     * @dev Only owner can pause\r\n     */\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n    \r\n    /**\r\n     * @notice Resumes staking operations\r\n     * @dev Only owner can unpause\r\n     */\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n    \r\n    /**\r\n     * @notice Emergency withdrawal (no cooldown, no rewards)\r\n     * @dev Only available when contract is paused\r\n     * @dev Use only in critical emergency situations\r\n     */\r\n    function emergencyWithdraw() external nonReentrant whenPaused {\r\n        Stake storage userStake = stakes[msg.sender];\r\n        \r\n        if (userStake.amount == 0) revert NoStakeFound();\r\n        \r\n        uint256 amount = userStake.amount;\r\n        \r\n        // EFFECTS: Update state BEFORE interaction\r\n        delete stakes[msg.sender];\r\n        totalStaked -= amount;\r\n        \r\n        // INTERACTIONS: External call LAST\r\n        if (!equorumToken.transfer(msg.sender, amount)) revert TransferFailed();\r\n        \r\n        emit EmergencyWithdraw(msg.sender, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/EquorumToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\n\r\n/**\r\n * @title EquorumToken\r\n * @notice Main ERC20 token for the Equorum ecosystem\r\n * @dev Optimized for Arbitrum L2 with efficient storage and gas patterns\r\n * \r\n * FEATURES:\r\n * - Fixed supply: 48,000,000 EQM\r\n * - Automatic distribution on deployment\r\n * - Pausable for emergencies (circuit breaker)\r\n * - Blacklist functionality for security\r\n * - Non-upgradeable (no proxy pattern)\r\n * \r\n * ADMIN CONTROLS (TRANSPARENCY):\r\n * - Owner can pause/unpause transfers (emergency only)\r\n * - Owner can blacklist/unblacklist addresses (malicious actors)\r\n * - Owner should be a Gnosis Safe multisig (2/3 or 3/5)\r\n * - After full configuration, owner can renounceOwnership() for true immutability\r\n * - All admin actions emit events for transparency\r\n * \r\n * RECOMMENDED SETUP:\r\n * - Deploy with owner = Gnosis Safe multisig\r\n * - Configure all contracts via setters\r\n * - Optionally renounceOwnership() after configuration\r\n * \r\n * ARBITRUM L2 OPTIMIZATIONS:\r\n * - Compact storage layout\r\n * - Minimal cross-contract calls\r\n * - Efficient event emission\r\n * - Gas-optimized transfers\r\n */\r\ncontract EquorumToken is ERC20, Ownable, Pausable {\r\n    \r\n    // ========== CUSTOM ERRORS ==========\r\n    /// @notice Thrown when address is zero or invalid\r\n    error InvalidAddress();\r\n    /// @notice Thrown when contract address is already set\r\n    error AlreadySet();\r\n    /// @notice Thrown when address is already blacklisted\r\n    error AlreadyBlacklisted();\r\n    /// @notice Thrown when address is not blacklisted\r\n    error NotBlacklisted();\r\n    /// @notice Thrown when sender is blacklisted\r\n    error SenderBlacklisted();\r\n    /// @notice Thrown when recipient is blacklisted\r\n    error RecipientBlacklisted();\r\n    /// @notice Thrown when trying to blacklist a protected address\r\n    error CannotBlacklistProtected();\r\n    \r\n    // ========== CONSTANTS ==========\r\n    /// @notice Total fixed supply - 48 million tokens\r\n    uint256 public constant TOTAL_SUPPLY = 48_000_000 * 1e18;\r\n    \r\n    /// @notice Token allocations (percentages of total supply)\r\n    /// @dev These constants are used for one-time distribution only\r\n    uint256 public constant STAKING_ALLOCATION = 38_000_000 * 1e18;  // 79.17% - Staking rewards\r\n    uint256 public constant ICO_ALLOCATION = 4_000_000 * 1e18;       // 8.33%  - Initial Coin Offering\r\n    uint256 public constant GENESIS_ALLOCATION = 3_000_000 * 1e18;   // 6.25%  - Genesis vesting (72 months)\r\n    uint256 public constant FAUCET_ALLOCATION = 2_256_000 * 1e18;    // 4.70%  - Faucet distribution\r\n    uint256 public constant LIQUIDITY_ALLOCATION = 500_000 * 1e18;   // 1.04%  - Initial liquidity\r\n    uint256 public constant FOUNDATION_ALLOCATION = 122_000 * 1e18;  // 0.25%  - Foundation reserve\r\n    uint256 public constant CORPORATE_ALLOCATION = 122_000 * 1e18;   // 0.25%  - Corporate reserve\r\n    \r\n    // ========== STATE VARIABLES ==========\r\n    /// @notice Blacklist mapping for blocked addresses\r\n    /// @dev Used for emergency blocking of malicious actors\r\n    mapping(address => bool) public blacklisted;\r\n    \r\n    /// @notice Contract addresses for token distribution\r\n    /// @dev Set once during initialization, cannot be changed after\r\n    address public stakingContract;      // Staking rewards contract\r\n    address public faucetContract;       // Faucet distribution contract\r\n    address public reserveManager;       // Reserve management contract (Foundation + Corporate)\r\n    address public genesisVesting;       // Genesis vesting contract\r\n    address public icoContract;          // ICO contract (set later when ready)\r\n    \r\n    // ========== EVENTS ==========\r\n    event Blacklisted(address indexed account);\r\n    event Unblacklisted(address indexed account);\r\n    event StakingContractSet(address indexed stakingContract);\r\n    event FaucetContractSet(address indexed faucetContract);\r\n    event ReserveManagerSet(address indexed reserveManager);\r\n    event GenesisVestingSet(address indexed genesisVesting);\r\n    event ICOContractSet(address indexed icoContract);\r\n    \r\n    // ========== CONSTRUCTOR ==========\r\n    /**\r\n     * @notice Initializes the token and distributes the supply\r\n     * @param _liquidityAddress Address for initial liquidity\r\n     * @dev Mints total supply and performs immediate distribution of liquidity only\r\n     * @dev Remaining tokens stay in contract for later allocation via setter functions\r\n     * @dev ICO allocation (4M tokens) remains in contract until setICOContract is called\r\n     */\r\n    constructor(\r\n        address _liquidityAddress\r\n    ) ERC20(\"Equorum\", \"EQM\") {\r\n        if (_liquidityAddress == address(0)) revert InvalidAddress();\r\n        \r\n        // Mint total supply to contract\r\n        _mint(address(this), TOTAL_SUPPLY);\r\n        \r\n        // Immediate distribution (liquidity only)\r\n        _transfer(address(this), _liquidityAddress, LIQUIDITY_ALLOCATION);\r\n        \r\n        // Remaining tokens stay in contract for allocation:\r\n        // - Staking: 38M (via setStakingContract)\r\n        // - Faucet: 2.256M (via setFaucetContract)\r\n        // - Reserve: 244K (via setReserveManager - includes Foundation + Corporate)\r\n        // - Genesis: 3M (via setGenesisVesting)\r\n        // - ICO: 4M (via setICOContract - when ready to launch ICO)\r\n    }\r\n    \r\n    // ========== ADMIN FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Sets the staking contract address (one-time only)\r\n     * @param _stakingContract Address of the staking contract\r\n     * @dev Transfers STAKING_ALLOCATION tokens to the staking contract\r\n     * @dev Can only be called once, cannot be changed after\r\n     */\r\n    function setStakingContract(address _stakingContract) external onlyOwner {\r\n        if (_stakingContract == address(0)) revert InvalidAddress();\r\n        if (stakingContract != address(0)) revert AlreadySet();\r\n        \r\n        stakingContract = _stakingContract;\r\n        _transfer(address(this), _stakingContract, STAKING_ALLOCATION);\r\n        \r\n        emit StakingContractSet(_stakingContract);\r\n    }\r\n    \r\n    /**\r\n     * @notice Sets the faucet contract address (one-time only)\r\n     * @param _faucetContract Address of the faucet contract\r\n     * @dev Transfers FAUCET_ALLOCATION tokens to the faucet contract\r\n     * @dev Can only be called once, cannot be changed after\r\n     */\r\n    function setFaucetContract(address _faucetContract) external onlyOwner {\r\n        if (_faucetContract == address(0)) revert InvalidAddress();\r\n        if (faucetContract != address(0)) revert AlreadySet();\r\n        \r\n        faucetContract = _faucetContract;\r\n        _transfer(address(this), _faucetContract, FAUCET_ALLOCATION);\r\n        \r\n        emit FaucetContractSet(_faucetContract);\r\n    }\r\n    \r\n    /**\r\n     * @notice Sets the reserve manager contract (one-time only)\r\n     * @param _reserveManager Address of the reserve manager contract\r\n     * @dev Transfers FOUNDATION_ALLOCATION + CORPORATE_ALLOCATION tokens (244K total)\r\n     * @dev Can only be called once, cannot be changed after\r\n     */\r\n    function setReserveManager(address _reserveManager) external onlyOwner {\r\n        if (_reserveManager == address(0)) revert InvalidAddress();\r\n        if (reserveManager != address(0)) revert AlreadySet();\r\n        \r\n        reserveManager = _reserveManager;\r\n        uint256 totalReserve = FOUNDATION_ALLOCATION + CORPORATE_ALLOCATION;\r\n        _transfer(address(this), _reserveManager, totalReserve);\r\n        \r\n        emit ReserveManagerSet(_reserveManager);\r\n    }\r\n    \r\n    /**\r\n     * @notice Sets the Genesis vesting contract address (one-time only)\r\n     * @param _genesisVesting Address of the Genesis vesting contract\r\n     * @dev Transfers GENESIS_ALLOCATION tokens to the vesting contract\r\n     * @dev Can only be called once, cannot be changed after\r\n     */\r\n    function setGenesisVesting(address _genesisVesting) external onlyOwner {\r\n        if (_genesisVesting == address(0)) revert InvalidAddress();\r\n        if (genesisVesting != address(0)) revert AlreadySet();\r\n        \r\n        genesisVesting = _genesisVesting;\r\n        _transfer(address(this), _genesisVesting, GENESIS_ALLOCATION);\r\n        \r\n        emit GenesisVestingSet(_genesisVesting);\r\n    }\r\n    \r\n    /**\r\n     * @notice Sets the ICO contract address (one-time only)\r\n     * @param _icoContract Address of the ICO contract\r\n     * @dev Transfers ICO_ALLOCATION tokens (4M) to the ICO contract\r\n     * @dev Can only be called once, cannot be changed after\r\n     * @dev Should only be called when ready to launch ICO (Phase 2/3)\r\n     */\r\n    function setICOContract(address _icoContract) external onlyOwner {\r\n        if (_icoContract == address(0)) revert InvalidAddress();\r\n        if (icoContract != address(0)) revert AlreadySet();\r\n        \r\n        icoContract = _icoContract;\r\n        _transfer(address(this), _icoContract, ICO_ALLOCATION);\r\n        \r\n        emit ICOContractSet(_icoContract);\r\n    }\r\n    \r\n    /**\r\n     * @notice Adds an address to the blacklist\r\n     * @param account Address to be blacklisted\r\n     * @dev Blacklisted addresses cannot send or receive tokens\r\n     * @dev Use only for emergency situations (e.g., malicious actors)\r\n     * @dev Cannot blacklist this contract or zero address\r\n     */\r\n    function blacklist(address account) external onlyOwner {\r\n        if (account == address(0)) revert InvalidAddress();\r\n        if (account == address(this)) revert CannotBlacklistProtected();\r\n        if (blacklisted[account]) revert AlreadyBlacklisted();\r\n        \r\n        blacklisted[account] = true;\r\n        emit Blacklisted(account);\r\n    }\r\n    \r\n    /**\r\n     * @notice Removes an address from the blacklist\r\n     * @param account Address to be unblacklisted\r\n     * @dev Restores transfer capabilities for the address\r\n     */\r\n    function unblacklist(address account) external onlyOwner {\r\n        if (!blacklisted[account]) revert NotBlacklisted();\r\n        \r\n        blacklisted[account] = false;\r\n        emit Unblacklisted(account);\r\n    }\r\n    \r\n    /**\r\n     * @notice Pauses all token transfers (emergency only)\r\n     * @dev Use in case of critical security issues\r\n     * @dev Only owner can pause\r\n     */\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n    \r\n    /**\r\n     * @notice Resumes token transfers\r\n     * @dev Only owner can unpause\r\n     */\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n    \r\n    // ========== OVERRIDES ==========\r\n    \r\n    /**\r\n     * @notice Hook that is called before any token transfer\r\n     * @dev Checks for paused state and blacklisted addresses\r\n     * @dev Optimized for Arbitrum L2 with minimal gas overhead\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override whenNotPaused {\r\n        if (blacklisted[from]) revert SenderBlacklisted();\r\n        if (blacklisted[to]) revert RecipientBlacklisted();\r\n        \r\n        super._beforeTokenTransfer(from, to, amount);\r\n    }\r\n    \r\n    // ========== VIEW FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Checks if all contracts have been configured\r\n     * @return bool True if all distribution addresses are set\r\n     * @dev Used to verify complete initialization before launch\r\n     */\r\n    function isFullyConfigured() external view returns (bool) {\r\n        return stakingContract != address(0) &&\r\n               faucetContract != address(0) &&\r\n               reserveManager != address(0) &&\r\n               genesisVesting != address(0);\r\n        // Note: icoContract is NOT required for initial configuration\r\n        // It will be set later when ready to launch ICO\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns distribution information for all allocations\r\n     * @return stakingBalance Balance in staking contract\r\n     * @return faucetBalance Balance in faucet contract\r\n     * @return reserveBalance Balance in reserve manager (Foundation + Corporate)\r\n     * @return genesisBalance Balance in genesis vesting\r\n     * @return remainingInContract Balance remaining in token contract\r\n     * @dev Useful for monitoring token distribution status\r\n     */\r\n    function getDistributionInfo() external view returns (\r\n        uint256 stakingBalance,\r\n        uint256 faucetBalance,\r\n        uint256 reserveBalance,\r\n        uint256 genesisBalance,\r\n        uint256 remainingInContract\r\n    ) {\r\n        stakingBalance = stakingContract != address(0) ? balanceOf(stakingContract) : 0;\r\n        faucetBalance = faucetContract != address(0) ? balanceOf(faucetContract) : 0;\r\n        reserveBalance = reserveManager != address(0) ? balanceOf(reserveManager) : 0;\r\n        genesisBalance = genesisVesting != address(0) ? balanceOf(genesisVesting) : 0;\r\n        remainingInContract = balanceOf(address(this));\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IEquorumCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @title IEquorumCore\r\n * @author Equorum Protocol\r\n * @notice Unified interface for Equorum Protocol core contracts\r\n * @dev All main contracts implement this interface for standardization and interoperability\r\n * \r\n * ARBITRUM L2 OPTIMIZATIONS:\r\n * - Minimal calldata usage\r\n * - Event-driven architecture for off-chain indexing\r\n * - Gas-efficient parameter updates\r\n */\r\ninterface IEquorumCore {\r\n    /**\r\n     * @notice Processes a system action\r\n     * @dev Action types: 1=Regular, 2=Critical, 3=Emergency\r\n     * @param actionType Type of action to process\r\n     * @param data Additional action data (ABI encoded)\r\n     */\r\n    function processSystemAction(uint8 actionType, bytes calldata data) external;\r\n\r\n    /**\r\n     * @notice Stops the contract in case of emergency\r\n     * @dev Should pause all critical functions\r\n     * @param reason Reason for emergency stop\r\n     */\r\n    function emergencyStop(string calldata reason) external;\r\n\r\n    /**\r\n     * @notice Updates contract parameters\r\n     * @dev Arrays must have matching lengths\r\n     * @param params Array of parameter names to update\r\n     * @param values Array of corresponding values\r\n     */\r\n    function updateParameters(string[] calldata params, uint256[] calldata values) external;\r\n\r\n    /**\r\n     * @notice Validates current contract state\r\n     * @dev Returns hash of critical state variables for verification\r\n     * @return checksum Hash of current state\r\n     */\r\n    function validateState() external view returns (bytes32 checksum);\r\n\r\n    /**\r\n     * @notice Verifies integration with other contracts\r\n     * @dev Checks if contract addresses are valid and accessible\r\n     * @param contracts Array of contract addresses to verify\r\n     * @return valid True if all integrations are valid\r\n     */\r\n    function verifyIntegrations(address[] calldata contracts) external view returns (bool valid);\r\n\r\n    // ========== EVENTS ==========\r\n    \r\n    /**\r\n     * @notice Emitted when a system action is processed\r\n     * @param contractAddress Address of contract processing action\r\n     * @param action Description of action\r\n     * @param value Numeric value associated with action\r\n     * @param timestamp Block timestamp of action\r\n     */\r\n    event SystemAction(\r\n        address indexed contractAddress,\r\n        string action,\r\n        uint256 value,\r\n        uint256 timestamp\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a parameter is updated\r\n     * @param contractAddress Address of contract being updated\r\n     * @param parameter Name of parameter updated\r\n     * @param oldValue Previous value\r\n     * @param newValue New value\r\n     * @param timestamp Block timestamp of update\r\n     */\r\n    event ParameterUpdate(\r\n        address indexed contractAddress,\r\n        string indexed parameter,\r\n        uint256 oldValue,\r\n        uint256 newValue,\r\n        uint256 timestamp\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when emergency action is taken\r\n     * @param contractAddress Address of contract in emergency\r\n     * @param reason Reason for emergency action\r\n     * @param timestamp Block timestamp of emergency\r\n     */\r\n    event EmergencyAction(\r\n        address indexed contractAddress,\r\n        string reason,\r\n        uint256 timestamp\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when integration validation is performed\r\n     * @param contractAddress Address of contract validating\r\n     * @param contracts Array of contracts validated\r\n     * @param success True if validation passed\r\n     * @param timestamp Block timestamp of validation\r\n     */\r\n    event IntegrationValidation(\r\n        address indexed contractAddress,\r\n        address[] contracts,\r\n        bool success,\r\n        uint256 timestamp\r\n    );\r\n}\r\n"
    },
    "contracts/TimeLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @title TimeLock\r\n * @author Equorum Protocol\r\n * @notice Secure timelock contract for delayed transaction execution\r\n * @dev Optimized for Arbitrum L2 with minimal storage operations\r\n * \r\n * FEATURES:\r\n * - Fixed delay: 48 hours (prevents rushed malicious proposals)\r\n * - Grace period: 7 days (window to execute after delay)\r\n * - Queue  Execute pattern (standard timelock flow)\r\n * - Cancellation support (admin can cancel queued transactions)\r\n * - Single admin (should be EquorumGovernance contract)\r\n * \r\n * SECURITY MODEL:\r\n * - All transactions must wait 48h before execution\r\n * - Transactions expire after 7 days grace period\r\n * - Only admin (governance) can queue/execute/cancel\r\n * - ETH can be received for proposal execution\r\n * \r\n * DEPLOYMENT FLOW:\r\n * 1. Deploy TimeLock with admin = deployer (temporary)\r\n * 2. Deploy EquorumGovernance pointing to TimeLock\r\n * 3. Call changeAdmin(governanceAddress) to transfer control\r\n * 4. TimeLock is now controlled by governance\r\n * \r\n * ARBITRUM L2 OPTIMIZATIONS:\r\n * - Custom errors for gas savings (~200 gas per revert)\r\n * - Minimal storage writes\r\n * - Efficient hash computation\r\n * \r\n * IMPORTANT: Proposals with ETH values require the executor to provide\r\n * the ETH via msg.value. For zero-value proposals, no ETH is needed.\r\n */\r\ncontract TimeLock {\r\n    \r\n    // ========== CUSTOM ERRORS ==========\r\n    error NotAdmin();\r\n    error InvalidAddress();\r\n    error ETANotReached();\r\n    error ETATooSoon();\r\n    error TransactionExpired();\r\n    error TransactionNotQueued();\r\n    error TransactionAlreadyQueued();\r\n    error ExecutionFailed();\r\n    error NotPendingAdmin();\r\n    \r\n    // ========== CONSTANTS ==========\r\n    /// @notice Minimum delay before a queued transaction can be executed\r\n    uint256 public constant DELAY = 48 hours;\r\n    \r\n    /// @notice Time window after ETA during which transaction can be executed\r\n    uint256 public constant GRACE_PERIOD = 7 days;\r\n    \r\n    // ========== STATE VARIABLES ==========\r\n    /// @notice Current admin address (should be EquorumGovernance)\r\n    address public admin;\r\n    \r\n    /// @notice Pending admin for two-step transfer (optional)\r\n    address public pendingAdmin;\r\n    \r\n    /// @notice Mapping of transaction hash to queued status\r\n    mapping(bytes32 => bool) public queuedTransactions;\r\n    \r\n    // ========== EVENTS ==========\r\n    event TransactionQueued(\r\n        bytes32 indexed txHash,\r\n        address indexed target,\r\n        uint256 value,\r\n        string signature,\r\n        bytes data,\r\n        uint256 eta\r\n    );\r\n    \r\n    event TransactionExecuted(\r\n        bytes32 indexed txHash,\r\n        address indexed target,\r\n        uint256 value,\r\n        string signature,\r\n        bytes data\r\n    );\r\n    \r\n    event TransactionCanceled(bytes32 indexed txHash);\r\n    event AdminChanged(address indexed previousAdmin, address indexed newAdmin);\r\n    event NewPendingAdmin(address indexed newPendingAdmin);\r\n    \r\n    // ========== MODIFIERS ==========\r\n    modifier onlyAdmin() {\r\n        if (msg.sender != admin) revert NotAdmin();\r\n        _;\r\n    }\r\n    \r\n    // ========== CONSTRUCTOR ==========\r\n    /**\r\n     * @notice Initializes the TimeLock contract\r\n     * @param _admin Initial admin address (typically deployer, then changed to governance)\r\n     */\r\n    constructor(address _admin) {\r\n        if (_admin == address(0)) revert InvalidAddress();\r\n        admin = _admin;\r\n        emit AdminChanged(address(0), _admin);\r\n    }\r\n    \r\n    // ========== TIMELOCK FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Queue a transaction for delayed execution\r\n     * @param target Target contract address\r\n     * @param value ETH value to send with the call\r\n     * @param signature Function signature (e.g., \"transfer(address,uint256)\")\r\n     * @param data Encoded function parameters\r\n     * @param eta Execution timestamp (must be >= block.timestamp + DELAY)\r\n     * @return txHash The unique hash identifying this transaction\r\n     */\r\n    function queueTransaction(\r\n        address target,\r\n        uint256 value,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint256 eta\r\n    ) external onlyAdmin returns (bytes32) {\r\n        if (eta < block.timestamp + DELAY) revert ETATooSoon();\r\n        \r\n        bytes32 txHash = keccak256(\r\n            abi.encode(target, value, signature, data, eta)\r\n        );\r\n        \r\n        if (queuedTransactions[txHash]) revert TransactionAlreadyQueued();\r\n        \r\n        queuedTransactions[txHash] = true;\r\n        \r\n        emit TransactionQueued(txHash, target, value, signature, data, eta);\r\n        \r\n        return txHash;\r\n    }\r\n    \r\n    /**\r\n     * @notice Execute a queued transaction after the delay has passed\r\n     * @param target Target contract address\r\n     * @param value ETH value to send (must match msg.value from governance)\r\n     * @param signature Function signature\r\n     * @param data Encoded function parameters\r\n     * @param eta Execution timestamp (must match the queued ETA)\r\n     * @return returnData The return data from the executed call\r\n     * @dev Transaction must be within the execution window: [eta, eta + GRACE_PERIOD]\r\n     */\r\n    function executeTransaction(\r\n        address target,\r\n        uint256 value,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint256 eta\r\n    ) external payable onlyAdmin returns (bytes memory) {\r\n        if (target == address(0)) revert InvalidAddress();\r\n        \r\n        bytes32 txHash = keccak256(\r\n            abi.encode(target, value, signature, data, eta)\r\n        );\r\n        \r\n        if (!queuedTransactions[txHash]) revert TransactionNotQueued();\r\n        if (block.timestamp < eta) revert ETANotReached();\r\n        if (block.timestamp > eta + GRACE_PERIOD) revert TransactionExpired();\r\n        \r\n        // Clear from queue before execution (reentrancy protection)\r\n        queuedTransactions[txHash] = false;\r\n        \r\n        // Build call data\r\n        bytes memory callData;\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(\r\n                bytes4(keccak256(bytes(signature))),\r\n                data\r\n            );\r\n        }\r\n        \r\n        // Execute the call\r\n        (bool success, bytes memory returnData) = target.call{value: value}(\r\n            callData\r\n        );\r\n        \r\n        if (!success) revert ExecutionFailed();\r\n        \r\n        emit TransactionExecuted(txHash, target, value, signature, data);\r\n        \r\n        return returnData;\r\n    }\r\n    \r\n    /**\r\n     * @notice Cancel a queued transaction\r\n     * @param target Target contract address\r\n     * @param value ETH value\r\n     * @param signature Function signature\r\n     * @param data Encoded function parameters\r\n     * @param eta Execution timestamp\r\n     */\r\n    function cancelTransaction(\r\n        address target,\r\n        uint256 value,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint256 eta\r\n    ) external onlyAdmin {\r\n        bytes32 txHash = keccak256(\r\n            abi.encode(target, value, signature, data, eta)\r\n        );\r\n        \r\n        if (!queuedTransactions[txHash]) revert TransactionNotQueued();\r\n        \r\n        queuedTransactions[txHash] = false;\r\n        \r\n        emit TransactionCanceled(txHash);\r\n    }\r\n    \r\n    // ========== ADMIN FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Immediately change admin to a new address (one-step transfer)\r\n     * @param newAdmin New admin address (typically EquorumGovernance)\r\n     * @dev CRITICAL: Use this after deploying governance to transfer control\r\n     * @dev This is the recommended way to set governance as admin\r\n     */\r\n    function changeAdmin(address newAdmin) external onlyAdmin {\r\n        if (newAdmin == address(0)) revert InvalidAddress();\r\n        \r\n        address previousAdmin = admin;\r\n        admin = newAdmin;\r\n        pendingAdmin = address(0);  // Clear any pending admin\r\n        \r\n        emit AdminChanged(previousAdmin, newAdmin);\r\n    }\r\n    \r\n    /**\r\n     * @notice Propose a new admin (two-step transfer, optional)\r\n     * @param newAdmin Address of the proposed new admin\r\n     * @dev Use changeAdmin() for immediate transfer to governance\r\n     */\r\n    function setPendingAdmin(address newAdmin) external onlyAdmin {\r\n        if (newAdmin == address(0)) revert InvalidAddress();\r\n        pendingAdmin = newAdmin;\r\n        emit NewPendingAdmin(newAdmin);\r\n    }\r\n    \r\n    /**\r\n     * @notice Accept admin role (must be called by pendingAdmin)\r\n     * @dev Part of two-step admin transfer process\r\n     */\r\n    function acceptAdmin() external {\r\n        if (msg.sender != pendingAdmin) revert NotPendingAdmin();\r\n        \r\n        address previousAdmin = admin;\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n        \r\n        emit AdminChanged(previousAdmin, admin);\r\n    }\r\n    \r\n    // ========== VIEW FUNCTIONS ==========\r\n    \r\n    /**\r\n     * @notice Check if a transaction is queued\r\n     * @param target Target contract address\r\n     * @param value ETH value\r\n     * @param signature Function signature\r\n     * @param data Encoded function parameters\r\n     * @param eta Execution timestamp\r\n     * @return True if transaction is queued\r\n     */\r\n    function isQueued(\r\n        address target,\r\n        uint256 value,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint256 eta\r\n    ) external view returns (bool) {\r\n        bytes32 txHash = keccak256(\r\n            abi.encode(target, value, signature, data, eta)\r\n        );\r\n        return queuedTransactions[txHash];\r\n    }\r\n    \r\n    /**\r\n     * @notice Calculate the hash of a transaction\r\n     * @param target Target contract address\r\n     * @param value ETH value\r\n     * @param signature Function signature\r\n     * @param data Encoded function parameters\r\n     * @param eta Execution timestamp\r\n     * @return Transaction hash\r\n     */\r\n    function getTransactionHash(\r\n        address target,\r\n        uint256 value,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint256 eta\r\n    ) external pure returns (bytes32) {\r\n        return keccak256(\r\n            abi.encode(target, value, signature, data, eta)\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @notice Check if a queued transaction is ready to execute\r\n     * @param target Target contract address\r\n     * @param value ETH value\r\n     * @param signature Function signature\r\n     * @param data Encoded function parameters\r\n     * @param eta Execution timestamp\r\n     * @return ready True if transaction can be executed now\r\n     * @return reason Status message\r\n     */\r\n    function canExecute(\r\n        address target,\r\n        uint256 value,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint256 eta\r\n    ) external view returns (bool ready, string memory reason) {\r\n        bytes32 txHash = keccak256(\r\n            abi.encode(target, value, signature, data, eta)\r\n        );\r\n        \r\n        if (!queuedTransactions[txHash]) {\r\n            return (false, \"Not queued\");\r\n        }\r\n        if (block.timestamp < eta) {\r\n            return (false, \"ETA not reached\");\r\n        }\r\n        if (block.timestamp > eta + GRACE_PERIOD) {\r\n            return (false, \"Expired\");\r\n        }\r\n        return (true, \"Ready\");\r\n    }\r\n    \r\n    // ========== RECEIVE ==========\r\n    \r\n    /// @notice Receive ETH for proposal execution\r\n    receive() external payable {}\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}